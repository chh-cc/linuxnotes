## 进程和线程

进程是操作系统资源分配（内存、显卡、磁盘）的最小单位，线程是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程）



做个简单的比喻，进程=火车，线程=车厢：

线程在进程下行进（单纯的车厢无法运行）

一个进程可以包含多个线程（一辆火车可以有多个车厢）

不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）

同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）

进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）

进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）

进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"

进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

## linux进程管理

在linux内核层面上，是**不区分进程和线程**的，在linux源代码里面，进程和线程都是统一用task_struct表示

### 前台后台命令

运行的命令后加入“&”字符，将工作放置到后台执行：`[root@test ~]# updatedb &`

通过“`ctrl+z`“将当前正在执行的命令放置到后台中并暂停执行

使用jobs命令可以查看目前后台程序工作状态：`jobs -l`

使用bg %jobnumber命令将后台暂停的命令在后台继续运行：`bg %1`

使用fg %jobnumber命令将后台暂停的命令拿到在前台继续运行：`fg %1`

### 程序管理

#### ps

ps 命令选项

| 选项 | 说明                         |
| ---- | ---------------------------- |
| -A   | 显示系统中所有进程信息       |
| -e   | 同-A选项                     |
| -l   | 使用详细格式显示进程信息     |
| -r   | 只显示目录正在运行的进程     |
| -u   | 以用户为主的方式显示进程信息 |
| -x   | 显示非终端上的进程信息       |
| -p   | 显示指定PID的进程信息        |

在linux中我们可以通过`ps aux `或` ps -ef `来查看我们系统中运行的进程情况

```shell
[root@test ~]# ps -aux
USER       PID %CPU %MEM    VSZ   RSS  TTY      STAT   START   TIME   COMMAND
root         1   0.0      0.2     2036   648   ?         Ss     12:03     0:08    init [5]                                          
root         2   0.0      0.0      0      0    ?          S     12:03     0:00    [migration/0]
root         3   0.0      0.0      0      0    ?         SN     12:03     0:00   [ksoftirqd/0]

USER：运行进程的用户名。

PID：运行进程的进程号。

%CPU：该进程占用CPU与总CPU比例。

%MEM：该进程占用内存和总内存比例。

VSZ：进程占用虚拟内存值，单位为KB。

RSS：进程占用物理内存值，单位为KB。

TTY：运行程序所对应的终端，？表示不占用终端一般为系统进程。

STAT：进程运行状态，R表示就绪，D表示不可中断的睡眠，S表示睡眠，T表示被跟踪或停止，Z表示终止（僵死），s表示子进程，<表示高优先级，n表示低优先级，+表示后台进程，｜表示锁定进程

START：进程开始执行的起始时间。

TIME：消耗CPU的总时间。

COMMAND：该进程所对应的命令名。
```

我们也可以通过指定格式只输出我们想看的信息

```shell
ps ao %p%C%c%U
PID %CPU      COMMAND         USER
1    0.0      init [5]        root                                  
2    0.0      [migration/0]   root
3    0.0      [ksoftirqd/0]   root
```

#### top



#### pstree

pstree 命令选项

| 选项 | 说明                                       |
| ---- | ------------------------------------------ |
| -a   | 显示每个程序的完整命令                     |
| -c   | 将相同的程序合并为一行显示                 |
| -h   | 列出树状程序，并高亮显示当前正在执行的程序 |
| -l   | 长格式显示                                 |
| -p   | 显示进程PID                                |
| -n   | 以PID大小进行排序，默认以程序名称进行排序  |
| -u   | 显示用户名称                               |
| -U   | 使用UTF-8编码显示                          |

例一：使用pstree命令查看当前系统进程结构。

```shell
[root@test ~]# pstree   

init-+-CDWserver

     |-acpid

     |-atd

     |-auditd-+-python

     |        `-{auditd}

     |-automount---4*[{automount}]

     |-avahi-daemon---avahi-daemon

     |-crond

     |-cupsd

     |-dbus-daemon

     |-events/0

     |-gdm-binary---gdm-binary-+-Xorg

     |                         `-gdmgreeter

     |-gdm-binary

     |-gpm

     |-hald---hald-runner-+-hald-addon-acpi

     |                    |-hald-addon-keyb

     |                    `-hald-addon-stor

………………………………………………………………
```

#### kill

kill命令用于将指定的信息送至程序，从而删除运行中的程序或工作

Linux中的信号总共有1-64个，其中常用的有信号1（SIGHUP）：重新读取配置文件；信号2（SIGINT）：中断正在运行的程序，类似ctrl+c功能；信号9（SIGKILL）：强制结束正在运行的程序；信号15（SIGTERM）：以正常方式结束进程。

例一：以正常方式结束PID为325的程序。

[root@test ~]# kill -15 325

例二：以强制方式结束在后台暂停的job number为2的程序。

[root@test ~]# kill -9 %2

若没有指定信号类型，默认为信号15，即以正常方式结束程序。

#### killall

killall命令具有和kill命令类似的功能，但kill命令需要加上PID号，所以常常需要结合ps命令一起使用，而killall命令后可以直接输入命令名称。具体语法格式如下所示：

[root@rhel ~]#  killall [信号] [命令名]

常用信号为1、2、9、15，于kill命令相同。

例一：以正常方式结束ksnapd进程运行。

[root@test ~]# killall -15 ksnapd

## 僵尸进程

指子进程结束后，父进程在等待子进程响应，子进程无法响应，进入死循环。

**影响系统资源，占用进程ID**

## 同步和异步、阻塞和非阻塞

同步阻塞：医院抢救，医生走不了，病人也走不了，必须抢救完后，大家才能做别的事情

同步非阻塞：大夫看一个棘手的病人，给别的科室打电话让别的大夫过来会诊，自己去做别的事，然后病人必须等着

异步非阻塞：发快递，你淘宝下单完后等着就行了，快递有时间了就给你送，大家都可以做别的事情



同步和异步是对调用者和被调用者来说的，它们是线程之间的关系，两个线程之间要么同步，要么异步

阻塞和非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞
