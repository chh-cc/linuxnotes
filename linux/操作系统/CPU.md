

## 使用率和平均负载

cpu使用率：cpu非空闲态下运行的时间占比，反应的是cpu的繁忙程度

平均负载：**单位时间内，系统处于可运行和不可中断的进程数**。它和我们传统意义上理解的CPU使用率并没有直接关系。



用银行来举例，cpu使用率就是工作人员1小时内的平均工作时间；平均负载就是一段时间内取钱的平均人数



现实工作中我们会经常混淆平均负载和CPU使用率的概念，其实两者并不完全对等：

- CPU密集型进程，大量CPU使用会导致平均负载升高，此时两者一致
- I/O密集型进程，等待I/O也会导致平均负载升高，此时CPU使用率并不一定高
- 大量等待CPU的进程调度会导致平均负载升高，此时CPU使用率也会比较高



负载高的时候可以使用 **mpstat、pidstat**等工具分析：

1、CPU 密集型进程

```shell
#-P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据
[root@luoahong ~]# mpstat -P ALL 5
03:47:20 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
03:47:25 PM  all   25.29    0.00    0.05    0.05    0.00    0.05    0.00    0.00    0.00   74.55
03:47:25 PM    0   99.80    0.00    0.00    0.00    0.00    0.20    0.00    0.00    0.00    0.00
03:47:25 PM    1    0.00    0.00    0.20    0.20    0.00    0.00    0.00    0.00    0.00   99.59
03:47:25 PM    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:47:25 PM    3    0.21    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.79

#正好有一个 CPU 的使用率为 100%，但其它的只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。

#查看哪个进程导致了 CPU 使用率为 100%
[root@luoahong ~]# pidstat -u 5 1
Linux 3.10.0-693.el7.x86_64 (luoahong) 02/05/2019 _x86_64_  (4 CPU)
 
03:51:51 PM UID PID %usr %system %guest %wait %CPU CPU Command
03:51:56 PM 0 79 0.00 0.59 0.00 0.20 0.59 2 kworker/2:2
03:51:56 PM 0 309 0.00 0.20 0.00 0.00 0.20 0 xfsaild/sda2
03:51:56 PM 0 738 0.40 0.00 0.00 0.20 0.40 1 vmtoolsd
03:51:56 PM 0 1308 99.80 0.20 0.00 0.00 100.00 3 stress #stress 进程的 CPU 使用率为 99.80
03:51:56 PM 0 1501 0.20 0.20 0.00 0.00 0.40 0 watch
03:51:56 PM 0 1752 0.00 0.40 0.00 0.00 0.40 1 pidstat
 
Average: UID PID %usr %system %guest %wait %CPU CPU Command
Average: 0 79 0.00 0.59 0.00 0.20 0.59 - kworker/2:2
Average: 0 309 0.00 0.20 0.00 0.00 0.20 - xfsaild/sda2
Average: 0 738 0.40 0.00 0.00 0.20 0.40 - vmtoolsd
Average: 0 1308 99.80 0.20 0.00 0.00 100.00 - stress
Average: 0 1501 0.20 0.20 0.00 0.00 0.40 - watch
Average: 0 1752 0.00 0.40 0.00 0.00 0.40 - pidstat
```

2、I/O 密集型进程

```shell
[root@luoahong ~]# mpstat -P ALL 5 1
Linux 3.10.0-693.el7.x86_64 (luoahong)  02/05/2019  _x86_64_    (2 CPU)
 
08:58:00 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08:58:05 PM  all    0.32    0.00   54.64   40.51    0.00    1.79    0.00    0.00    0.00    2.74
08:58:05 PM    0    0.43    0.00   27.55   66.59    0.00    3.47    0.00    0.00    0.00    1.95
08:58:05 PM    1    0.21    0.00   80.29   15.81    0.00    0.21    0.00    0.00    0.00    3.49
 
Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
Average:     all    0.32    0.00   54.64   40.51    0.00    1.79    0.00    0.00    0.00    2.74
Average:       0    0.43    0.00   27.55   66.59    0.00    3.47    0.00    0.00    0.00    1.95
Average:       1    0.21    0.00   80.29   15.81    0.00    0.21    0.00    0.00    0.00    3.49

#其中一个 CPU 的系统 CPU 使用率升高到了 27.55，而 iowait 高达 66.59%。这说明，平均负载的升高是由于 iowait 的升高。
```

3、当系统中运行进程超出CPU运行能力时，就会出现等待CPU的进程

```shell
[root@luoahong ~]# pidstat -u 5 1
Linux 3.10.0-693.el7.x86_64 (luoahong)  02/05/2019  _x86_64_    (2 CPU)
 
09:15:30 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
09:15:35 PM     0       683    0.20    0.00    0.00    1.37    0.20     0  vmtoolsd
09:15:35 PM     0      1049    0.00    0.20    0.00    0.00    0.20     0  tuned
09:15:35 PM     0      4622    0.00    0.39    0.00    0.39    0.39     1  kworker/1:0
09:15:35 PM     0      4624    0.20    0.20    0.00    0.59    0.39     0  watch
09:15:35 PM     0      5271   24.31    0.00    0.00   74.31   24.31     1  stress
09:15:35 PM     0      5272   24.51    0.00    0.00   74.12   24.51     0  stress
09:15:35 PM     0      5273   24.31    0.00    0.00   73.92   24.31     1  stress
09:15:35 PM     0      5274   24.12    0.00    0.00   74.12   24.12     0  stress
09:15:35 PM     0      5275   24.31    0.00    0.00   74.12   24.31     1  stress
09:15:35 PM     0      5276   24.31    0.20    0.00   73.73   24.51     0  stress
09:15:35 PM     0      5277   24.31    0.20    0.00   74.31   24.51     1  stress
09:15:35 PM     0      5278   24.31    0.20    0.00   74.71   24.51     0  stress
09:15:35 PM     0      5326    0.00    0.20    0.00    0.39    0.20     0  pidstat
 
Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:        0       683    0.20    0.00    0.00    1.37    0.20     -  vmtoolsd
Average:        0      1049    0.00    0.20    0.00    0.00    0.20     -  tuned
Average:        0      4622    0.00    0.39    0.00    0.39    0.39     -  kworker/1:0
Average:        0      4624    0.20    0.20    0.00    0.59    0.39     -  watch
Average:        0      5271   24.31    0.00    0.00   74.31   24.31     -  stress
Average:        0      5272   24.51    0.00    0.00   74.12   24.51     -  stress
Average:        0      5273   24.31    0.00    0.00   73.92   24.31     -  stress
Average:        0      5274   24.12    0.00    0.00   74.12   24.12     -  stress
Average:        0      5275   24.31    0.00    0.00   74.12   24.31     -  stress
Average:        0      5276   24.31    0.20    0.00   73.73   24.51     -  stress
Average:        0      5277   24.31    0.20    0.00   74.31   24.51     -  stress
Average:        0      5278   24.31    0.20    0.00   74.71   24.51     -  stress
Average:        0      5326    0.00    0.20    0.00    0.39    0.20     -  pidstat

#可以看出，8 个进程在争抢 2 个 CPU，每个进程等待CPU 的时间（也就是代码块中的 %wait 列）高达 75%这些超出 CPU 计算能力的进程，最终导致 CPU 过载。
```

