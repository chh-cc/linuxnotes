# 命令

## 控制台

基于我的运维工作经验给你汇总如下：

操作快捷键

```text
Ctrl + r：可以快速查找历史命令；

Ctrl + l：可以清理控制台屏幕；

Ctrl + a \ Ctrl + e：移动光标到命令行首\行尾；

Ctrl + w \ Ctrl + k：删除光标之前\之后的内容。
```

进程操作快捷键

```text
Ctrl + c：强制终止程序的执行；

Ctrl + z：挂起一个进程；

Ctrl + d：终端中输入 exit 后回车。
```

linux命令中快捷键（top）

```text
P：根据 CPU 使用率排序；
M：根据内存占用排序。
```





可以通过man cmd、cmd --help、help cmd、info cmd等方式查看命令的使用。

## 文件

```shell
ls -rtl                                    # 按修改时间倒叙列出所有目录和文件 ll -rt
ls -a                                      # 显示所有文件
ls -d                                      # 查看目录本身
ls -lSh |more                              # 从大到小排列文件和目录
ls -i                                      # 查看文件inode号

touch file                                 # 创建空白文件
rm -rf dirname                             # 不提示删除非空目录(-r:递归删除 -f强制)
md5sum                                     # 查看md5值

ln sourcefile newfile                      # 硬链接
ln -s sourcefile newfile                   # 符号连接

cat 
-b  显示非空行行号
-n  显示所有行行号
-T  显示tab，用^I表示
-E  显示以$结尾
# 将eof标准输入作为cat标准输出再覆盖到a.txt：
cat > a.txt << eof
> 123
> abc
> eof
# 追加到a.txt
cat >> a.txt << eof
> 123
> abc
> eof

head                                       # 查看文件开头内容
head -c 10m                                # 截取文件中10M内容

tail -f file                               # 查看结尾 监视日志文件
tail -F file                               # 监视日志并重试, 针对文件被mv的情况可以持续读取

file                                       # 检查文件类型
umask                                      # 更改默认权限

chattr +i /etc/passwd                      # 不得任意改变文件或目录 -i去掉锁 -R递归
more                                       # 向下分面器
locate aaa                                 # 搜索
wc -l file                                 # 查看行数

cp filename{,.bak}                         # 快速备份一个文件
-a                                         # 保持源文件权限，递归复制（常用
-r                                         # 递归持续复制，用于目录的复制行为（常用）；
\cp a b                                    # 拷贝不提示 既不使用别名 cp -i

rename source new file                     # 重命名 可正则

cut
-b  选中第几个字符
-c  选中多少个字符
-d  指定分隔符分字段，默认是空格
-f  显示选中字段
echo "abc" |cut -b "2"
b
echo "abcdef" |cut -c 1-3
abc
echo "a:b:c" |cut -d: -f2
b
```



```shell
sort排序{

        -t                                     # 指定分隔字符
        -n                                     # 依照数值的大小排序
        -r                                     # 以相反的顺序来排序
        -f                                     # 排序时，将小写字母视为大写字母

        -b                                     # 忽略每行前面开始处的空格字符
        -k                                     # 指定哪一列排序
        -m                                     # 将几个排序好的文件进行合并      

        sort -n                                # 按数字排序
        sort -nr                               # 按数字倒叙
        sort -u                                # 过滤重复行
        sort -m a.txt c.txt                    # 将两个文件内容整合到一起
        sort -n -t' ' -k 2 -k 3 a.txt          # 第二域相同，将从第三域进行升降处理
        sort -n -t':' -k 3r a.txt              # 以:为分割域的第三域进行倒叙排列
        sort -k 1.3 a.txt                      # 从第三个字母起进行排序
        sort -t" " -k 2n -u  a.txt             # 以第二域进行排序，如果遇到重复的，就删除

    }

uniq{
	uniq                                       # 删除重复的行
	uniq -c                                    # 重复的行出现次数
	uniq -d                                    # 只显示重复的行
	uniq -u                                    # 只显示不重复行
}
```



```shell
find查找{

        # linux文件无创建时间
        # Access 使用时间
        # Modify 内容修改时间
        # Change 状态改变时间(权限、属主)
        # 时间默认以24小时为单位,当前时间到向前24小时为0天,向前48-72小时为2天
        # -and 且 匹配两个条件 参数可以确定时间范围 -mtime +2 -and -mtime -4
        # -or 或 匹配任意一个条件
        
        格式：find path -option actions
        -name  文件名，支持(‘*’, ‘?’)
        -type  文件类型，d目录，f常规文件等
        -perm  符合权限的文件，比如755
        -user  文件属主
        -group 文件属组
        -atime -/+n  在n天以内/过去n天被访问过
        -ctime -/+n  在n天以内/过去n天被修改过
        -amin -/+n   在n天以内/过去n分钟被访问过
        -cmin -/+n   在n天以内/过去n分钟被修改过
        -size -/+n   文件大小小于/大于，b、k、M、G
        -maxdepth levels  目录层次显示的最大深度
        -regex pattern    文件名匹配正则表达式模式
        -inum     通过inode编号查找文件

        find /etc -name "*http*"                                # 按文件名查找
        find . -type f                                          # 查找某一类型文件
        find . ! -type f                                        # 查找不是某一类型的文件
        find /etc/* -name "*passwd*" -exec grep "xuesong" {} \;   # 按名字查找文件传递给-exec后命令
        find . -type f -name "err*" -exec  rename err ERR {} \; # 批量改名(查找err 替换为 ERR {}文件
        find path -name *name1* -or -name *name2*               # 查找任意一个关键字

    }
```



```shell
vim编辑器{

        # 常用配置
        set smartindent
        set tabstop=4
        set shiftwidth=4
        set expandtab
        set softtabstop=4
        set noautoindent
        set nosmartindent
        set paste
        set clipboard=unnamed

        gconf-editor           # 配置编辑器
        /etc/vimrc             # 配置文件路径
        vim +24 file           # 打开文件定位到指定行
        vim file1 file2        # 打开多个文件
        vim  -r file           # 恢复上次异常关闭的文件 .file.swp 
        vim -O2 file1 file2    # 垂直分屏
        vim -on file1 file2    # 水平分屏
        Ctrl+ U                # 向前翻页
        Ctrl+ D                # 向后翻页
        Ctrl+ww                # 在窗口间切换
        Ctrl+w +or-or=         # 增减高度
        :sp filename           # 上下分割打开新文件
        :vs filename           # 左右分割打开新文件
        :set nu                # 打开行号
        :set nonu              # 取消行号
        :nohl                  # 取消高亮
        :set paste             # 取消缩进
        :set autoindent        # 设置自动缩进
        :set ff                # 查看文本格式
        :set binary            # 改为unix格式
        :%s/str/newstr/g       # 全部替换
        :200                   # 跳转到200  1 文件头
        G                      # 跳到行尾
        dd                     # 删除当前行 并复制 可直接p粘贴
        11111dd                # 删除11111行，可用来清空文件
        r                      # 替换单个字符
        R                      # 替换多个字符
        u                      # 撤销上次操作
        *                      # 全文匹配当前光标所在字符串
        $                      # 行尾
        0                      # 行首
        X                      # 文档加密
        v =                    # 自动格式化代码
        Ctrl+v                 # 可视模式
        Ctrl+v I ESC           # 多行操作
        Ctrl+v s ESC           # 批量取消注释

    }
```



```shell
归档解压缩{
        tar
        -c   创建新归档
        -d   比较归档和文件系统的差异
        -r   追加文件到归档
        -t   存档的内容列表
        -x   提取归档所有文件
        -C   改变解压目录
        -f   使用归档文件或设备归档
        -j   bzip2压缩
        -z   gzip压缩
        -v   输出处理过程
        
        tar -cvf 1.tar *                                 # 打包tar
        tar -cf archive.tar foo bar
        tar xvf 1.tar -C dir                             # 解包tar 放到指定目录
        tar tvf 1.tar                                    # 查看tar
        tar -rvf 1.tar filename                          # 给tar追加文件
        
        tar zcvpf /$path/gz.tar.gz *                     # 打包gz 注意*最好用相对路径
        tar --exclude=/home/dmtsai --exclude=*.tar -zcvf myfile.tar.gz /home/* /etc                                                                # 打包/home, /etc ，但排除 /home/dmtsai
        tar -zcvfh home.tar.gz /home                     # 打包目录中包括连接目录
        tar zxvpf gz.tar.gz [dir]                        # 解包指定tar.gz中的内容  不指定目录则全解压
        tar ztvpf gz.tar.gz                              # 查看gz
        
        tar -N "2005/06/01" -zcvf home.tar.gz /home      # 在 /home 当中，比 2005/06/01 新的文件才备份
        
        zgrep str 1.gz                                   # 查看压缩包中文件字符行
        bzip2  -dv 1.tar.bz2                             # 解压bzip2
        bzip2 -v 1.tar                                   # bzip2压缩
        bzcat                                            # 查看bzip2
        gzip file                                        # 直接压缩文件 # 压缩后源文件消失
        gunzip file.gz                                   # 直接解压文件 # 解压后源文件消失
        gzip -r dir/                                     # 递归压缩目录
        gzip  -r -d dir/                                 # 递归解压目录
        gzip -dv 1.tar.gz                                # 解压gzip到tar
        gzip -v 1.tar                                    # 压缩tar到gz
        unzip zip.zip                                    # 解压zip
        zip zip.zip *                                    # 压缩zip
        rar a rar.rar *.jpg                              # 压缩文件为rar包
        unrar x rar.rar                                  # 解压rar包

    }
```



```shell
文件ACL权限控制{

        getfacl 1.test                      # 查看文件ACL权限
        setfacl -R -m u:xuesong:rw- 1.test  # 对文件增加用户的读写权限 -R 递归

    }
```

## git

```shell
git clone git@10.10.10.10:gittest.git  ./gittest/  # 克隆项目到指定目录
        git clone  -b develop --depth=1 http://git.a.com/d.git   # 克隆指定分支 克隆一层
        git status                                         # Show the working tree(工作树) status
        git log -n 1 --stat                                # 查看最后一次日志文件
        git branch -a                                      # 列出远程跟踪分支(remote-tracking branches)和本地分支
        git checkout developing                            # 切换到developing分支
        git checkout -b release                            # 切换分支没有从当前分支创建
        git checkout -b release origin/master              # 从远程分支创建本地镜像分支
        git push origin --delete release                   # 从远端删除分区，服务端有可能设置保护不允许删除
        git push origin release                            # 把本地分支提交到远程
        git pull                                           # 更新项目 需要cd到项目目录中
        git fetch -f -p                                    # 抓取远端代码但不合并到当前
        git reset --hard origin/master                     # 和远端同步分支
        git add .                                          # 更新所有文件
        git commit -m "gittest up"                         # 提交操作并添加备注
        git push                                           # 正式提交到远程git服务器
        git push [-u origin master]                        # 正式提交到远程git服务器(master分支)
        git tag [-a] dev-v-0.11.54 [-m 'fix #67']          # 创建tag,名为dev-v-0.11.54,备注fix #67
        git tag -l dev-v-0.11.54                           # 查看tag(dev-v-0.11.5)
        git push origin --tags                             # 提交tag
        git reset --hard                                   # 本地恢复整个项目
        git rm -r -n --cached  ./img                       # -n执行命令时,不会删除任何文件,而是展示此命令要删除的文件列表预览
        git rm -r --cached  ./img                          # 执行删除命令 需要commit和push让远程生效
        git init --bare smc-content-check.git              # 初始化新git项目  需要手动创建此目录并给git用户权限 chown -R git:git smc-content-check.git
        git config --global credential.helper store        # 记住密码
        git config [--global] user.name "your name"        # 设置你的用户名, 希望在一个特定的项目中使用不同的用户或e-mail地址, 不要--global选项
        git config [--global] user.email "your email"      # 设置你的e-mail地址, 每次Git提交都会使用该信息
        git config [--global] user.name                    # 查看用户名
        git config [--global] user.email                   # 查看用户e-mail
        git config --global --edit                         # 编辑~/.gitconfig(User-specific)配置文件, 值优先级高于/etc/gitconfig(System-wide)
        git config --edit                                  # 编辑.git/config(Repository specific)配置文件, 值优先级高于~/.gitconfig
        git cherry-pick  <commit id>                       # 用于把另一个本地分支的commit修改应用到当前分支 需要push到远程
        git log --pretty=format:'%h: %s' 9378b62..HEAD     # 查看指定范围更新操作 commit id
        git config --global core.ignorecase false          # 设置全局大小写敏感
        git ls-remote --heads origin refs/heads/test       # 查看

        从远端拉一份新的{
            # You have not concluded your merge (MERGE_HEAD exists)  git拉取失败
            git fetch --hard origin/master
            git reset --hard origin/master
        }

        删除远程分支并新建{
            git checkout master
            git branch -r -d origin/test       # 删除远程分支  但有时候并没有删除 可以尝试使用下面的语句
            git push origin :test              # 推送一个空分支到远程分支，相当于删除远程分支
            git branch -d test                 # 删除本地test分支, -D 强制
            git branch -a |grep test
            git checkout -b test
            git push origin test

            git reset --hard origin/test 
        }

        迁移git项目{
            git branch -r | grep -v '\->' | while read remote; do git branch --track "${remote#origin/}" "$remote"; done
            git fetch --all
            git pull --all
            git remote set-url origin git@git.github.cn:server/gw.git
            git push --all
        }
```

## 软件

```shell
 rpm{

        rpm -ivh lynx          # rpm安装
        rpm -e lynx            # 卸载包
        rpm -e lynx --nodeps   # 强制卸载
        rpm -qa                # 查看所有安装的rpm包
        rpm -qa | grep lynx    # 查找包是否安装
        rpm -ql                # 软件包路径
        rpm -Uvh               # 升级包
        rpm --test lynx        # 测试
        rpm -qc                # 软件包配置文档
        rpm --initdb           # 初始化rpm 数据库
        rpm --rebuilddb        # 重建rpm数据库  在rpm和yum无响应的情况使用 先 rm -f /var/lib/rpm/__db.00* 在重建

    }
```

```shell
yum{

        yum list                 # 所有软件列表
        yum install 包名          # 安装包和依赖包
        yum -y update            # 升级所有包版本,依赖关系，系统版本内核都升级
        yum -y update 软件包名    # 升级指定的软件包
        yum -y upgrade           # 不改变软件设置更新软件，系统版本升级，内核不改变
        yum search mail          # yum搜索相关包
        yum grouplist            # 软件包组
        yum -y groupinstall "Virtualization"   # 安装软件包组
        repoquery -ql gstreamer  # 不安装软件查看包含文件
        yum clean all            # 清除var下缓存

    }

yum使用epel源{

        # 包下载地址: http://download.fedoraproject.org/pub/epel   # 选择版本5\6\7
        rpm -Uvh  http://mirrors.hustunique.com/epel//6/x86_64/epel-release-6-8.noarch.rpm

        # 自适配版本
        yum install epel-release

    }
    
自定义yum源{

        find /etc/yum.repos.d -name "*.repo" -exec mv {} {}.bak \;

        vim /etc/yum.repos.d/yum.repo
        [yum]
        #http
        baseurl=http://10.0.0.1/centos5.5
        #挂载iso
        #mount -o loop CentOS-5.8-x86_64-bin-DVD-1of2.iso /data/iso/
        #本地
        #baseurl=file:///data/iso/
        enable=1

        #导入key
        rpm --import  /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5

    }
```

```shell
编译{

        源码安装{

            ./configure --help                   # 查看所有编译参数
            ./configure  --prefix=/usr/local/    # 配置参数
            make                                 # 编译
            # make -j8                          # 多线程编译,速度较快,但有些软件不支持
            make install                         # 安装包
            make clean                           # 清除编译结果

        }
```

## 系统

```shell
    查看信息(){
    	uname -a                                      # 查看 linux 版本
   	 	cat /etc/redhat-release                       # 查看 redhat/centos 版本号
   	 	
   	 	free -h                                       # 查看内存
   	 	cat /proc/cpuinfo							  # 查看 cpu 的核心数
   	 	curl ifconfig.me                              # 查看公网ip
   	 	ifconfig eth0                                 # 查看私网ip
   	 	who -u                                        # 登录用户
   	 	last -a|head -6                               # 登录用户
    }
    
    
    whereis ls                                    # 搜索程序名，而且只搜索二进制文件
    which                                         # 查找命令是否存在,及存放位置
    
    locate                                        # 不是实时查找，查找的结果不精确，但查找速度很快 每天更新 /var/lib/locatedb
    
    echo -n 123456 | md5sum                       # md5加密
    
    netstat -ntupl | grep port                    # 是否打开了某个端口
    
    ntpdate cn.pool.ntp.org                       # 同步时间, pool.ntp.org: public ntp time server for everyone(http://www.pool.ntp.org/zh/)
    tzselect                                      # 选择时区 #+8=(5 9 1 1) # (TZ='Asia/Shanghai'; export TZ)括号内写入 /etc/profile
    
    LANG=en                                       # 修改语言
    vim /etc/sysconfig/i18n                       # 修改编码  LANG="en_US.UTF-8"
    export LC_ALL=C                               # 强制字符集
    vi /etc/hosts                                 # 查询静态主机名
    alias                                         # 别名
    
    ps -mfL <PID>                                 # 查看指定进程启动的线程 线程数受 max user processes 限制
    ps uxm |wc -l                                 # 查看当前用户占用的进程数 [包括线程]  max user processes
    top -p  PID -H                                # 查看指定PID进程及线程
    
    lsof |wc -l                                   # 查看当前文件句柄数使用数量（所有打开的文件数）
    lsof /etc/passwd                              # 查看哪个进程占用文件
    lsof -i:80                                    # 查看80端口监听的进程
    lsof -p 5373                                  # 列出进程ID打开的文件
    
    nc
    常用选项：
-i interval 指定间隔时间发送和接受行文本
-l  监听模式，管理传入的连接
-n   不解析域名
-p  指定本地源端口
-s  指定本地源IP地址
-u  使用udp协议，默认是tcp
-v  执行过程输出
-w  timeout 连接超时时间
-x  proxy_address[:port]  请求连接主机使用代理地址和端口
-z  指定扫描监听端口，不发送任何数据
    
    nc -z 192.168.1.10 1-65535	# 端口扫描
    nc -z -w 2 192.168.1.10 22	# 探测端口是否开启

    sysctl -a                                     # 查看当前所有系统内核参数
    sysctl -p                                     # 修改内核参数/etc/sysctl.conf，让/etc/rc.d/rc.sysinit读取生效
    strace -p pid                                 # 跟踪系统调用
    ps -eo "%p %C  %z  %a"|sort -k3 -n            # 把进程按内存使用大小排序
    strace uptime 2>&1|grep open                  # 查看命令打开的相关文件
    grep Hugepagesize /proc/meminfo               # 内存分页大小
    echo 1 > /proc/sys/net/ipv4/tcp_syncookies    # 使TCP SYN Cookie 保护生效  # "SYN Attack"是一种拒绝服务的攻击方式
    grep Swap  /proc/25151/smaps |awk '{a+=$2}END{print a}'    # 查询某pid使用的swap大小
    redir --lport=33060 --caddr=10.10.10.78 --cport=3306       # 端口映射 yum安装 用supervisor守护
```



```shell
开机启动脚本顺序{

        /etc/profile
        /etc/profile.d/*.sh
        ~/bash_profile
        ~/.bashrc
        /etc/bashrc

    }
```



```shell
进程管理{

        ps -eaf               # 查看所有进程
        kill -9 PID           # 强制终止某个PID进程
        kill -15 PID          # 安全退出 需程序内部处理信号
        cmd &                 # 使用&命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉(退出帐户时)，作业就会在后台当做一个进程使用。
        nohup cmd &           # 使用了nohup之后，很多人就这样不管了，其实这样有可能在当前账户非正常退出或者结束的时候，命令还是自己结束了。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，这样才能保证命令一直在后台运行。
        ctrl+z                # 将前台放入后台(暂停)
        jobs                  # 查看后台运行程序
        bg 2                  # 启动后台暂停进程
        fg 2                  # 调回后台进程
        pstree                # 进程树
        vmstat 1 9            # 每隔一秒报告系统性能信息9次
        sar                   # 查看cpu等状态
        lsof file             # 显示打开指定文件的所有进程
        lsof -i:32768         # 查看端口的进程
        renice +1 180         # 把180号进程的优先级加1
        exec sh a.sh          # 子进程替换原来程序的pid， 避免supervisor无法强制杀死进程

        ps{
            常用选项:
            -a  显示所有进程
            -u  选择有效的用户ID或名称
            -x  显示无控制终端的进程
            -e  显示所有进程
            -f  全格式
            -r  只显示运行的进程
            -T  这个终端的所有进程
            -p  指定进程ID
            --sort  对某列排序
            -m  线程
            -L  格式化代码列表
            -o  用户自定义格式
            
            ps aux	# 打印系统上所有进程BSD语法
            ps aux |grep -v USER | sort -nk +4 | tail       # 显示消耗内存最多的10个运行中的进程，以内存使用量排序.cpu +3
            # USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
            %CPU     # 进程的cpu占用率
            %MEM     # 进程的内存占用率
            VSZ      # 进程虚拟大小,单位K(即总占用内存大小,包括真实内存和虚拟内存)
            RSS      # 进程使用的驻留集大小即实际物理内存大小
                     # 占用的虚拟内存大小 = VSZ - RSS
            STAT     # 进程状态
                     R-可执行；只有在该状态的进程才可能在CPU上运行。可执行说的2种，正在运行的和等待运行的，若cpu没有多余时间片，将等待运行。
                     S-可中断睡眠；等待某某事件的发生（比如等待socket连接、等待信号量、sleep函数）而被挂起。
                     D-不可中断睡眠；想关闭不可中断进程状态的话，通过 kill -9 命令关闭是做不到的。这种情况下，只能通过重启操作系统进行恢复或者所需资源。
                     I-空闲
                     T-暂停或跟踪
                     Z-僵尸进程；如果子进程在exit之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”
                     X-即将销毁
            START    # 进程启动时间和日期

            ps -ef                               # 打印系统上所有进程标准语法
            ps axjf 或 ps -ejH                   # 打印进程树
            ps -Lfp PID                          # 查看进程启动的线程
            ps uxm 或 ps -U root -u root u       # 查看当前用户的进程数
            ps -eo user,pid,pcpu,pmem,nice,lstart,time,args --sort=-pcpu
            或 
            ps -eo "%U %p %C %n %x %a"           # 自定义格式显示并对CPU排序
        }

        top{
            top
            top - 15:27:15 up  4:47,  3 users,  load average: 0.16, 0.05, 0.06
			Tasks: 205 total,   1 running, 204 sleeping,   0 stopped,   0 zombie
			%Cpu(s):  2.3 us,  1.0 sy,  0.0 ni, 96.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
			KiB Mem :   995896 total,    66188 free,   663556 used,   266152 buff/cache
			KiB Swap:  2097148 total,  2059836 free,    37312 used.    94216 avail Mem 
            
            #按1可查看每个逻辑CPU的状况
			#默认进入top时，按CPU的占用量来排序的
			#top不适合长时间检测负载信息，短命的进程也会遗漏
			#平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。
			#平均负载并非使用率。cpu使用率顶多100%，不可能120%，但负载可以是200%，因为还有等待运行的进程。
			
            前五行是系统整体的统计信息。
            第一行: 任务队列信息，同 uptime 命令的执行结果。内容如下：
                   15:27:15 当前时间
                   up 4:47 系统运行时间，格式为时:分
                   3 user 当前登录用户数
                   load average: 0.16, 0.05, 0.06 系统负载，即任务队列的平均长度。
                   三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。
                   当平均负载超过cpu核心数70%就要注意了，可能有大量任务堆积，需要排查。
                   
            第二、三行:为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下：
                     Tasks: 205 total 进程总数
                     1 running 正在运行的进程数（包括正在cpu和将被调度运行的）
                     204 sleeping 等待事件完成的进程数
                     0 stopped 被暂停的的进程数
                     0 zombie 僵尸进程数
                     2.3 us 用户空间占用CPU百分比，用户 CPU使用率高，通常说明有应用程序比较繁忙
                     1.0 sy 内核空间占用CPU百分比，系统 CPU 使用率高，说明内核比较繁忙
                     0.0 ni 用户进程空间内改变过优先级的进程占用CPU百分比
                     96.6 id 空闲CPU百分比
                     0.0 wa 等待输入输出的CPU时间百分比，在进行IO操作的时候，如果程序是阻塞的，他cpu会等待数据写入磁盘才能完成写操作。所以这个时候cpu等待的时间就是wa。wa特别高，那么一般说明是磁盘IO出现问题
                     0.0 hi
                     0.0 si

            第四、五行:为内存信息。内容如下：
                Mem: 191272k total 物理内存总量
                173656k used 使用的物理内存总量
                17616k free 空闲内存总量
                22052k buffers 用作内核缓存的内存量
                Swap: 192772k total 交换区总量
                0k used 使用的交换区总量
                192772k free 空闲交换区总量
                123988k cached 缓冲的交换区总量。
                内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，
                该数值即为这些内容已存在于内存中的交换区的大小。
                相应的内存再次被换出时可不必再对交换区写入。

            进程信息区,各列的含义如下:  # 显示各个进程的详细信息

            序号 列名    含义
            a   PID      进程id
            b   PPID     父进程id
            c   RUSER    Real user name
            d   UID      进程所有者的用户id
            e   USER     进程所有者的用户名
            f   GROUP    进程所有者的组名
            g   TTY      启动进程的终端名。不是从终端启动的进程则显示为 ?
            h   PR       优先级
            i   NI       nice值。负值表示高优先级，正值表示低优先级
            j   P        最后使用的CPU，仅在多CPU环境下有意义
            k   %CPU     上次更新到现在的CPU时间占用百分比
            l   TIME     进程使用的CPU时间总计，单位秒
            m   TIME+    进程使用的CPU时间总计，单位1/100秒
            n   %MEM     进程使用的物理内存百分比
            o   VIRT     进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
            p   SWAP     进程使用的虚拟内存中，被换出的大小，单位kb。
            q   RES      进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
            r   CODE     可执行代码占用的物理内存大小，单位kb
            s   DATA     可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
            t   SHR      共享内存大小，单位kb
            u   nFLT     页面错误次数
            v   nDRT     最后一次写入到现在，被修改过的页面数。
            w   S        进程状态。
                D=不可中断的睡眠状态
                R=运行
                S=睡眠
                T=跟踪/停止
                Z=僵尸进程 父进程在但并不等待子进程
            x   COMMAND  命令名/命令行
            y   WCHAN    若该进程在睡眠，则显示睡眠中的系统函数名
            z   Flags    任务标志，参考 sched.h

        }

        列出正在占用swap的进程{

            #!/bin/bash
            echo -e "PID\t\tSwap\t\tProc_Name"
            # 拿出/proc目录下所有以数字为名的目录（进程名是数字才是进程，其他如sys,net等存放的是其他信息）
            for pid in `ls -l /proc | grep ^d | awk '{ print $9 }'| grep -v [^0-9]`
            do
                # 让进程释放swap的方法只有一个：就是重启该进程。或者等其自动释放。放
                # 如果进程会自动释放，那么我们就不会写脚本来找他了，找他都是因为他没有自动释放。
                # 所以我们要列出占用swap并需要重启的进程，但是init这个进程是系统里所有进程的祖先进程
                # 重启init进程意味着重启系统，这是万万不可以的，所以就不必检测他了，以免对系统造成影响。
                if [ $pid -eq 1 ];then continue;fi
                grep -q "Swap" /proc/$pid/smaps 2>/dev/null
                if [ $? -eq 0 ];then
                    swap=$(grep Swap /proc/$pid/smaps \
                        | gawk '{ sum+=$2;} END{ print sum }')
                    proc_name=$(ps aux | grep -w "$pid" | grep -v grep \
                        | awk '{ for(i=11;i<=NF;i++){ printf("%s ",$i); }}')
                    if [ $swap -gt 0 ];then
                        echo -e "${pid}\t${swap}\t${proc_name}"
                    fi
                fi
            done | sort -k2 -n | awk -F'\t' '{
                pid[NR]=$1;
                size[NR]=$2;
                name[NR]=$3;
            }
            END{
                for(id=1;id<=length(pid);id++)
                {
                    if(size[id]<1024)
                        printf("%-10s\t%15sKB\t%s\n",pid[id],size[id],name[id]);
                    else if(size[id]<1048576)
                        printf("%-10s\t%15.2fMB\t%s\n",pid[id],size[id]/1024,name[id]);
                    else
                        printf("%-10s\t%15.2fGB\t%s\n",pid[id],size[id]/1048576,name[id]);
                }
            }'

        }

        linux操作系统提供的信号{

            kill -l                    # 查看linux提供的信号
            trap "echo aaa"  2 3 15    # shell使用 trap 捕捉退出信号

            # 发送信号一般有两种原因:
            #   1(被动式)  内核检测到一个系统事件.例如子进程退出会像父进程发送SIGCHLD信号.键盘按下control+c会发送SIGINT信号
            #   2(主动式)  通过系统调用kill来向指定进程发送信号
            # 进程结束信号 SIGTERM 和 SIGKILL 的区别:  SIGTERM 比较友好，进程能捕捉这个信号，根据您的需要来关闭程序。在关闭程序之前，您可以结束打开的记录文件和完成正在做的任务。在某些情况下，假如进程正在进行作业而且不能中断，那么进程可以忽略这个SIGTERM信号。
            # 如果一个进程收到一个SIGUSR1信号，然后执行信号绑定函数，第二个SIGUSR2信号又来了，第一个信号没有被处理完毕的话，第二个信号就会丢弃。

            SIGHUP  1          A     # 终端挂起或者控制进程终止
            SIGINT  2          A     # 键盘终端进程(如control+c)
            SIGQUIT 3          C     # 键盘的退出键被按下
            SIGILL  4          C     # 非法指令
            SIGABRT 6          C     # 由abort(3)发出的退出指令
            SIGFPE  8          C     # 浮点异常
            SIGKILL 9          AEF   # Kill信号  立刻停止
            SIGSEGV 11         C     # 无效的内存引用
            SIGPIPE 13         A     # 管道破裂: 写一个没有读端口的管道
            SIGALRM 14         A     # 闹钟信号 由alarm(2)发出的信号
            SIGTERM 15         A     # 终止信号,可让程序安全退出 kill -15
            SIGUSR1 30,10,16   A     # 用户自定义信号1
            SIGUSR2 31,12,17   A     # 用户自定义信号2
            SIGCHLD 20,17,18   B     # 子进程结束自动向父进程发送SIGCHLD信号
            SIGCONT 19,18,25         # 进程继续（曾被停止的进程）
            SIGSTOP 17,19,23   DEF   # 终止进程
            SIGTSTP 18,20,24   D     # 控制终端（tty）上按下停止键
            SIGTTIN 21,21,26   D     # 后台进程企图从控制终端读
            SIGTTOU 22,22,27   D     # 后台进程企图从控制终端写

            缺省处理动作一项中的字母含义如下:
                A  缺省的动作是终止进程
                B  缺省的动作是忽略此信号，将该信号丢弃，不做处理
                C  缺省的动作是终止进程并进行内核映像转储(dump core),内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。
                D  缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）
                E  信号不能被捕获
                F  信号不能被忽略
        }

        系统性能状态{

            vmstat 1 9

            r      等待执行的任务数。当这个值超过了cpu线程数，就会出现cpu瓶颈。
            b      # 等待IO的进程数量,表示阻塞的进程。经常大于3，表示io性能不好。
            swpd   # 虚拟内存已使用的大小，如大于0，表示机器物理内存不足，如不是程序内存泄露，那么该升级内存。
            free   # 空闲的物理内存的大小
            buff   # 已用的buff大小，对块设备的读写进行缓冲
            cache  # cache直接用来记忆我们打开的文件,给文件做缓冲，(把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)
            inact  非活跃内存大小，即被标明可回收的内存，区别于free和active -a选项时显示
            active 活跃的内存大小 -a选项时显示
            si   每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露，要查找耗内存进程解决掉。
            so   每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。
            bi   块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte
            bo   块设备每秒发送的块数量，例如读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。
            in   每秒CPU的中断次数，包括时间中断。in和cs这两个值越大，会看到由内核消耗的cpu时间会越多
            cs   每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用。
            us   # 用户进程执行消耗cpu时间(user time)  us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施
            sy   # 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。
            id   # 空闲 CPU时间，一般来说，id + us + sy = 100,一般认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。
            wt   # 等待IOCPU时间。Wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。
        }
```



```shell
日志管理{

        history                      # 历时命令默认1000条
        HISTTIMEFORMAT="%Y-%m-%d %H:%M:%S "   # 让history命令显示具体时间
        history  -c                  # 清除记录命令
        cat $HOME/.bash_history      # 历史命令记录文件
        lastb -a                     # 列出登录系统失败的用户相关信息  清空二进制日志记录文件 echo > /var/log/btmp
        last                         # 查看登陆过的用户信息  清空二进制日志记录文件 echo > /var/log/wtmp   默认打开乱码
        who /var/log/wtmp            # 查看登陆过的用户信息
        lastlog                      # 用户最后登录的时间
        tail -f /var/log/messages    # 系统日志
        tail -f /var/log/secure      # ssh日志

    }
```



```shell
查看剩余内存{

        free -m
        #-/+ buffers/cache:       6458       1649
        #6458M为真实使用内存  1649M为真实剩余内存(剩余内存+缓存+缓冲器)
        #linux会利用所有的剩余内存作为缓存，所以要保证linux运行速度，就需要保证内存的缓存大小

    }
```



```shell
硬件信息{

        more /proc/cpuinfo                                       # 查看cpu信息
        lscpu                                                    # 查看cpu信息
        cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c    # 查看cpu型号和逻辑核心数
        getconf LONG_BIT                                         # cpu运行的位数
        cat /proc/cpuinfo | grep 'physical id' |sort| uniq -c    # 物理cpu个数
        cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l     # 结果大于0支持64位
        cat /proc/cpuinfo|grep flags                             # 查看cpu是否支持虚拟化   pae支持半虚拟化  IntelVT 支持全虚拟化
        more /proc/meminfo                                       # 查看内存信息
        dmidecode                                                # 查看全面硬件信息
        dmidecode | grep "Product Name"                          # 查看服务器型号
        dmidecode | grep -P -A5 "Memory\s+Device" | grep Size | grep -v Range       # 查看内存插槽
        cat /proc/mdstat                                         # 查看软raid信息
        cat /proc/scsi/scsi                                      # 查看Dell硬raid信息(IBM、HP需要官方检测工具)
        lspci                                                    # 查看硬件信息
        lspci|grep RAID                                          # 查看是否支持raid
        lspci -vvv |grep Ethernet                                # 查看网卡型号
        lspci -vvv |grep Kernel|grep driver                      # 查看驱动模块
        modinfo tg2                                              # 查看驱动版本(驱动模块)
        ethtool -i em1                                           # 查看网卡驱动版本
        ethtool em1                                              # 查看网卡带宽

    }
```



```shell
开机启动模式{

        vi /etc/inittab
        id:3:initdefault:    # 3为多用户命令
        #ca::ctrlaltdel:/sbin/shutdown -t3 -r now   # 注释此行 禁止 ctrl+alt+del 关闭计算机

    }
```



```shell
终端提示显示{

        echo $PS1                   # 环境变量控制提示显示
        PS1='[\u@ \H \w \A \@#]\$'
        PS1='[\u@\h \W]\$'
        export PS1='[\[\e[32m\]\[\e[31m\]\u@\[\e[36m\]\h \w\[\e[m\]]\$ '     # 高亮显示终端

    }
```



```shell
定时任务{

        crontab -u 用户名 -e               # 编辑周期任务
        #分钟  小时    天  月  星期   命令或脚本
        1,30  1-3/2    *   *   *      命令或脚本  >> file.log 2>&1
        echo "40 7 * * 2 /root/sh">>/var/spool/cron/work    # 普通用户可直接写入定时任务
        crontab -l                                          # 查看自动周期性任务
        crontab -r                                          # 删除自动周期性任务
        * * * * *  echo "d" >>d$(date +\%Y\%m\%d).log       # 让定时任务直接生成带日期的log  需要转义%

    }
```



```shell
date{

        星期日[SUN] 星期一[MON] 星期二[TUE] 星期三[WED] 星期四[THU] 星期五[FRI] 星期六[SAT]
        一月[JAN] 二月[FEB] 三月[MAR] 四月[APR] 五月[MAY] 六月[JUN] 七月[JUL] 八月[AUG] 九月[SEP] 十月[OCT] 十一月[NOV] 十二月[DEC]

        date -s 20091112                     # 设日期
        date -s 18:30:50                     # 设时间
        date -d "7 days ago" +%Y%m%d         # 7天前日期
        date -d "5 minute ago" +%H:%M        # 5分钟前时间
        date -d "1 month ago" +%Y%m%d        # 一个月前
        date -d '1 days' +%Y-%m-%d           # 一天后
        date -d '1 hours' +%H:%M:%S          # 一小时后
        date +%Y-%m-%d -d '20110902'         # 日期格式转换
        date +%Y-%m-%d_%X                    # 日期和时间
        date +%N                             # 纳秒
        date -d "2012-08-13 14:00:23" +%s    # 换算成秒计算(1970年至今的秒数)
        date -d "@1363867952" +%Y-%m-%d-%T   # 将时间戳换算成日期
        date -d "1970-01-01 UTC 1363867952 seconds" +%Y-%m-%d-%T  # 将时间戳换算成日期
        date -d "`awk -F. '{print $1}' /proc/uptime` second ago" +"%Y-%m-%d %H:%M:%S"    # 格式化系统启动时间(多少秒前)

    }
```



```shell
limits.conf{

        ulimit -SHn 65535  # 临时设置文件描述符大小 进程最大打开文件柄数 还有socket最大连接数, 等同配置 nofile
        ulimit -SHu 65535  # 临时设置用户最大进程数
        ulimit -a          # 查看

        /etc/security/limits.conf

        # 文件描述符大小  open files
        # lsof |wc -l   查看当前文件句柄数使用数量
        * soft nofile 16384         # 设置太大，进程使用过多会把机器拖死
        * hard nofile 32768

        # 用户最大进程数  max user processes
        # echo $((`ps uxm |wc -l`-`ps ux |wc -l`))  查看当前用户占用的进程数 [包括线程]
        user soft nproc 16384
        user hard nproc 32768

        # 如果/etc/security/limits.d/有配置文件，将会覆盖/etc/security/limits.conf里的配置
        # 即/etc/security/limits.d/的配置文件里就不要有同样的参量设置
        /etc/security/limits.d/90-nproc.conf    # centos6.3的默认这个文件会覆盖 limits.conf
        user soft nproc 16384
        user hard nproc 32768

        sysctl -p    # 修改配置文件后让系统生效

    }
```

```shell
百万长链接设置{

        # 内存消耗需要较大
        vim /root/.bash_profile
        # 添加如下2行,退出bash重新登陆
        # 一个进程不能使用超过NR_OPEN文件描述符
        echo 20000500 > /proc/sys/fs/nr_open
        # 当前用户最大文件数
        ulimit -n 10000000

    }
```



```shell
sudo{

        echo myPassword | sudo -S ls /tmp  # 直接输入sudo的密码非交互,从标准输入读取密码而不是终端设备
        visudo                             # sudo命令权限添加  /etc/sudoers
        用户  别名(可用all)=NOPASSWD:命令1,命令2
        user  ALL=NOPASSWD:/bin/su         # 免root密码切换root身份
        wangming linuxfan=NOPASSWD:/sbin/apache start,/sbin/apache restart
        UserName ALL=(ALL) ALL
        UserName ALL=(ALL) NOPASSWD: ALL
        peterli        ALL=(ALL)       NOPASSWD:/sbin/service
        Defaults requiretty                # sudo不允许后台运行,注释此行既允许
        Defaults !visiblepw                # sudo不允许远程,去掉!既允许

    }
```



```shell
服务{

    /etc/init.d/sendmail start                   # 启动服务
    /etc/init.d/sendmail stop                    # 关闭服务
    /etc/init.d/sendmail status                  # 查看服务当前状态
    /date/mysql/bin/mysqld_safe --user=mysql &   # 启动mysql后台运行
    /bin/systemctl restart  mysqld.service       # centos7启动服务
    vi /etc/rc.d/rc.local                        # 开机启动执行  可用于开机启动脚本
    /etc/rc.d/rc3.d/S55sshd                      # 开机启动和关机关闭服务连接    # S开机start  K关机stop  55级别 后跟服务名
    ln -s -f /date/httpd/bin/apachectl /etc/rc.d/rc3.d/S15httpd   # 将启动程序脚本连接到开机启动目录
    ipvsadm -ln                                  # lvs查看后端负载机并发
    ipvsadm -C                                   # lvs清除规则
    xm list                                      # 查看xen虚拟主机列表
    virsh                                        # 虚拟化(xen\kvm)管理工具  yum groupinstall Virtual*
    ./bin/httpd -M                               # 查看httpd加载模块
    httpd -t -D DUMP_MODULES                     # rpm包httpd查看加载模块
    echo 内容| /bin/mail -s "标题" 收件箱 -f 发件人       # 发送邮件
    "`echo "内容"|iconv -f utf8 -t gbk`" | /bin/mail -s "`echo "标题"|iconv -f utf8 -t gbk`" 收件箱     # 解决邮件乱码
    /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg   # 检测nagios配置文件

    chkconfig{

        chkconfig service on|off|set             # 设置非独立服务启状态
        chkconfig --level 35   httpd   off       # 让服务不自动启动
        chkconfig --level 35   httpd   on        # 让服务自动启动 35指的是运行级别
        chkconfig --list                         # 查看所有服务的启动状态
        chkconfig --list |grep httpd             # 查看某个服务的启动状态
        chkconfig –-list [service]               # 查看服务的状态

    }

    systemctl{

        systemctl is-active *.service      # 查看服务是否运行
        systemctl is-enabled *.service     # 查询服务是否开机启动
        systemctl mask *.service           # 注销指定服务
        systemctl unmask cups.service      # 取消注销cups服务
        systemctl enable *.service         # 开机运行服务
        systemctl disable *.service        # 取消开机运行
        systemctl start *.service          # 启动服务
        systemctl stop *.service           # 停止服务
        systemctl restart *.service        # 重启服务
        systemctl reload *.service         # 重新加载服务配置文件
        systemctl status *.service         # 查询服务运行状态
        systemctl --failed                 # 显示启动失败的服务
        systemctl poweroff                 # 系统关机
        systemctl reboot                   # 重新启动
        systemctl rescue                   # 强制进入救援模式
        systemctl emergency                # 强制进入紧急救援模式
        systemctl list-dependencies        # 查看当前运行级别target(mult-user)启动了哪些服务
        systemctl list-unit-files          # 查看开机启动的状态
        journalctl -r -u elasticsearch.service  # 查看日志 r倒序 u服务名
        /etc/systemd/system/falcon-agent.service
            [Unit]
            Description=This is zuiyou monitor agent
            After=network.target remote-fs.target nss-lookup.target

            [Service]
            User= root
            Type=simple
            PIDFile=/opt/falcon-agent/var/app.pid
            ExecStartPre=/usr/bin/rm -f /opt/falcon-agent/var/app.pid
            ExecStart=/opt/falcon-agent/control start
            ExecReload=/bin/kill -s HUP $MAINPID
            KillMode=process
            KillSignal=SIGQUIT
            TimeoutStopSec=5
            PrivateTmp=true
            Restart=always
            LimitNOFILE=infinity

            [Install]
            WantedBy=multi-user.target

        systemctl daemon-reload           # 加载配置

    }
```

##  网络

```shell
    rz                                                                    # 通过ssh上传小文件
    sz                                                                    # 通过ssh下载小文件
    
    ifconfig eth0 down                                                    # 禁用网卡
    ifconfig eth0 up                                                      # 启用网卡
    ifup eth0:0                                                           # 启用网卡
    mii-tool em1                                                          # 查看网线是否连接
    
    hostname -I															  # 查看主机所有非回环IP
    traceroute www.baidu.com                                              # 测试跳数
    vi /etc/resolv.conf                                                   # 设置DNS  nameserver IP 定义DNS服务器的IP地址
    nslookup www.moon.com                                                 # 解析域名IP
    dig -x www.baidu.com                                                  # 解析域名IP
    dig +trace -t A domainname                                            # 跟踪dns
    dig +short txt hacker.wp.dg.cx                                        # 通过 DNS 来读取 Wikipedia 的hacker词条
    host -t txt hacker.wp.dg.cx                                           # 通过 DNS 来读取 Wikipedia 的hacker词条
    
    wget
    -O	#写入内容到文件
    -c	#断点续传
    
    curl
    -C	#断点续传
    -s	#静默模式，不输出任何内容
    -o	#输出到文件
    curl -I www.baidu.com                                                 # 查看网页http头
    curl -s www.baidu.com                                                 # 不显示进度
    
    telnet ip port                                                        # 测试端口是否开放,有些服务可直接输入命令得到返回状态
    echo "show " |nc $ip $port                                            # 适用于telnet一类登录得到命令返回
    nc -l -p port                                                         # 监听指定端口
    nc -nv -z 10.10.10.11 1080 |grep succeeded                            # 检查主机端口是否开放
    curl -o /dev/null -s -m 10 --connect-timeout 10 -w %{http_code} $URL  # 检查页面状态
    curl -X POST -d "user=xuesong&pwd=123" http://www.abc.cn/Result       # 提交POST请求
    curl -s http://20140507.ip138.com/ic.asp                              # 通过IP138取本机出口外网IP
    curl http://IP/ -H "X-Forwarded-For: ip" -H "Host: www.ttlsa.com"     # 连到指定IP的响应主机,HTTPserver只看 Host字段
    ifconfig eth0:0 192.168.1.221 netmask 255.255.255.0                   # 增加逻辑IP地址
    echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all                      # 禁ping
    net rpc shutdown -I IP_ADDRESS -U username%password                   # 远程关掉一台WINDOWS机器
    wget --random-wait -r -p -e robots=off -U Mozilla www.example.com     # 递归方式下载整个网站
    sshpass -p "$pwd" rsync -avzP /dir  user@$IP:/dir/                    # 指定密码避免交互同步目录
    
    rsync -avzP --delete /dir/ user@$IP:/dir/                             # 无差同步目录 可以快速清空大目录,末尾带/同步目录
    rsync -avzP -e "ssh -p 22 -e -o StrictHostKeyChecking=no" /dir user@$IP:/dir         # 指定ssh参数同步
```



```shell
抓包{

        -i eth1                             # 只抓经过接口eth1的包
        -t                                  # 不显示时间戳
        -s 0                                # 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包
        -c 100                              # 只抓取100个数据包
        dst port ! 22                       # 不抓取目标端口是22的数据包
        tcpdump tcp port 22                 # 抓包
        tcpdump -n -vv udp port 53          # 抓udp的dns包 并显示ip
        tcpdump port 10001 -A -s0           # 完整显示ascii数据包
        tcpdump -i any  host x.x.x.x -s 0 -w /tmp/cap.pcap   # 对端ip
        tcpdump -i any -s 0 host 172.20.81.107 or host 172.16.3.72 -C 50 -W 5 -w /tmp/20190122ng.cap

    }
```



```shell
网卡流量查看{

        watch more /proc/net/dev    # 实时监控流量文件系统 累计值
        iptraf                      # 网卡流量查看工具
        nethogs -d 5 eth0 eth1      # 按进程实时统计网络流量 epel源nethogs
        iftop -i eth0 -n -P         # 实时流量监控

        sar {
            -n参数有6个不同的开关: DEV | EDEV | NFS | NFSD | SOCK | ALL
            DEV显示网络接口信息
            EDEV显示关于网络错误的统计数据
            NFS统计活动的NFS客户端的信息
            NFSD统计NFS服务器的信息
            SOCK显示套 接字信息
            ALL显示所有5个开关

            sar -n DEV 1 10

            rxpck/s   # 每秒钟接收的数据包
            txpck/s   # 每秒钟发送的数据包
            rxbyt/s   # 每秒钟接收的字节数
            txbyt/s   # 每秒钟发送的字节数
            rxcmp/s   # 每秒钟接收的压缩数据包
            txcmp/s   # 每秒钟发送的压缩数据包
            rxmcst/s  # 每秒钟接收的多播数据包

        }

    }
```



```shell
netstat{

        # 几十万并发的情况下netstat会没有响应，建议使用 ss 命令
        -a     # 显示所有连接中的Socket
        -t     # 显示TCP连接
        -u     # 显示UDP连接
        -n     # 显示所有已建立的有效连接
        netstat -anlp           # 查看链接
        netstat -tnlp           # 只查看tcp监听端口
        netstat -r              # 查看路由表
    }
    
并发数查看{

        netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
        SYN_RECV     # 正在等待处理的请求
        ESTABLISHED  # 正常数据传输状态,既当前并发数
        TIME_WAIT    # 处理完毕，等待超时结束的请求
        CLOSE_WAIT   # 客户端异常关闭,没有完成4次挥手  如大量可能存在攻击行为

    }
```

```shell
ss{

        # netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多
        ss -s                          # 列出当前socket详细信息
        ss -l                          # 显示本地打开的所有端口
        ss -tnlp                       # 显示每个进程具体打开的socket
        ss -ant                        # 显示所有TCP socket
        ss -u -a                       # 显示所有UDP Socekt
        
        ss dst 192.168.119.113         # 匹配远程地址
        ss dst 192.168.119.113:http    # 匹配远程地址和端口号
        ss dst 192.168.119.113:3844    # 匹配远程地址和端口号
        ss src 192.168.119.103:16021   # 匹配本地地址和端口号
        ss -o state established '( dport = :smtp or sport = :smtp )'        # 显示所有已建立的SMTP连接
        ss -o state established '( dport = :http or sport = :http )'        # 显示所有已建立的HTTP连接
        ss -x src /tmp/.X11-unix/*         # 找出所有连接X服务器的进程

    }
```



```shell
ssh{

        ssh -p 22 user@192.168.1.209                            # 从linux ssh登录另一台linux
        ssh -p 22 root@192.168.1.209 CMD                        # 利用ssh操作远程主机
        
        scp -P 22 file root@ip:/dir                             # 把本地文件拷贝到远程主机
        scp -l 100000  file root@ip:/dir                        # 传输文件到远程，限制速度100M
        
        sshpass -p 'pwd' ssh -n root@$IP "echo hello"           # 指定密码远程操作
        ssh -o StrictHostKeyChecking=no $IP                     # ssh连接不提示yes
        ssh -t "su -"                                           # 指定伪终端 客户端以交互模式工作
        scp root@192.168.1.209:/RemoteDir /localDir             # 把远程指定文件拷贝到本地
        pscp -h host.ip /a.sh /opt/sbin/                        # 批量传输文件
        ssh -N -L2001:remotehost:80 user@somemachine            # 用SSH创建端口转发通道
        ssh -t host_A ssh host_B                                # 嵌套使用SSH
        ssh -t -p 22 $user@$Ip /bin/su - root -c {$Cmd};        # 远程su执行命令 Cmd="\"/sbin/ifconfig eth0\""
        
        ssh-keygen -t rsa                                       # 生成密钥
        ssh-copy-id -i /root/.ssh/id_rsa.pub xuesong@10.10.10.133                     # 传送公钥
        sshpass -pAa123456 ssh-copy-id -i /root/.ssh/id_rsa.pub xuesong@10.10.10.133  # 免交互传送公钥
        vi $HOME/.ssh/authorized_keys                           # 公钥存放位置
        
        ssh user@host cat /path/to/remotefile | diff /path/to/localfile -                # 用DIFF对比远程文件跟本地文件
        su - user -c "ssh user@192.168.1.1 \"echo -e aa |mail -s test mail@163.com\""    # 切换用户登录远程发送邮件
        pssh -h ip.txt -i uptime                                # 批量执行ssh yum install pssh

        SSH反向连接{

            # 外网A要控制内网B

            ssh -NfR 1234:localhost:2223 user1@123.123.123.123 -p22    # 将A主机的1234端口和B主机的2223端口绑定，相当于远程端口映射
            ss -ant   # 这时在A主机上sshd会listen本地1234端口
            # LISTEN     0    128    127.0.0.1:1234       *:*
            ssh localhost -p1234    # 在A主机连接本地1234端口

        }
    }

解决ssh链接慢{

        sed -i 's/GSSAPIAuthentication yes/GSSAPIAuthentication no/' /etc/ssh/sshd_config
        sed -i '/#UseDNS yes/a\UseDNS no' /etc/ssh/sshd_config
        /etc/init.d/sshd reload

}
```



```shell
网卡配置文件{

        vi /etc/sysconfig/network-scripts/ifcfg-eth0

        DEVICE=eth0
        BOOTPROTO=none
        BROADCAST=192.168.1.255
        HWADDR=00:0C:29:3F:E1:EA
        IPADDR=192.168.1.55
        NETMASK=255.255.255.0
        NETWORK=192.168.1.0
        ONBOOT=yes
        TYPE=Ethernet
        GATEWAY=192.168.1.1
        #ARPCHECK=no     # 进制arp检查

}
DNS配置文件{
	vim /etc/resolv.conf
	domain  domain_name       # 声明本地域名，即解析时自动隐式补齐的域名
	search  domain_name_list  # 指定域名搜索顺序(最多6个)，和domain不能共存，若共存了，则后面的行生效
	nameserver  IP1           # 设置DNS指向，最多3个
	nameserver  IP2
	nameserver  IP3        
	options timeout:n attempts:n  # 指定解析超时时间(默认5秒)和解析次数(默认2次)
}

服务端口{
grep '^ftp\|^ssh' /etc/services 
ftp-data        20/tcp
ftp-data        20/udp
ftp             21/tcp
ftp             21/udp          fsp fspd
ssh             22/tcp                          # The Secure Shell (SSH) Protocol
ssh             22/udp                          # The Secure Shell (SSH) Protocol
ftp-data        20/sctp                 # FTP
ftp             21/sctp                 # FTP
ssh             22/sctp                 # SSH
ftp-agent       574/tcp                 # FTP Software Agent System
ftp-agent       574/udp                 # FTP Software Agent System
sshell          614/tcp                 # SSLshell
sshell          614/udp                 #       SSLshell
ftps-data       989/tcp                 # ftp protocol, data, over TLS/SSL
ftps-data       989/udp                 # ftp protocol, data, over TLS/SSL
ftps            990/tcp                 # ftp protocol, control, over TLS/SSL
ftps            990/udp                 # ftp protocol, control, over TLS/SSL
ssh-mgmt        17235/tcp               # SSH Tectia Manager
ssh-mgmt        17235/udp               # SSH Tectia Manager
}
```



```shell
route {

        route -n                          # 查看路由表
        route add default  gw 192.168.1.1  dev eth0                        # 添加默认路由
        route add -net 172.16.0.0 netmask 255.255.0.0 gw 10.39.111.254     # 添加静态路由网关
        route del -net 172.16.0.0 netmask 255.255.0.0 gw 10.39.111.254     # 删除静态路由网关

    }
```



```shell
nmap{

        nmap -PT 192.168.1.1-111             # 先ping在扫描主机开放端口
        nmap -O 192.168.1.1                  # 扫描出系统内核版本
        nmap -sV 192.168.1.1-111             # 扫描端口的软件版本
        nmap -sS 192.168.1.1-111             # 半开扫描(通常不会记录日志)
        nmap -P0 192.168.1.1-111             # 不ping直接扫描
        nmap -d 192.168.1.1-111              # 详细信息
        nmap -D 192.168.1.1-111              # 无法找出真正扫描主机(隐藏IP)
        nmap -p 20-30,139,60000-             # 端口范围  表示：扫描20到30号端口，139号端口以及所有大于60000的端口
        nmap -P0 -sV -O -v 192.168.30.251    # 组合扫描(不ping、软件版本、内核版本、详细信息)

    }
```

## 硬盘

操作系统读取硬盘的时候，是一次性连续读取多个扇区，即一次性读取一个”块”（block）。
”块”的大小，最常见的是4KB

文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。

**每一个文件都有对应的inode**，里面包含了与该文件有关的一些信息。

inode包含文件的元信息，具体来说有以下内容：

```text
　　* 文件的字节数
　　* 文件拥有者的User ID
　　* 文件的Group ID
　　* 文件的读、写、执行权限
　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。
　　* 链接数，即有多少文件名指向这个inode
　　* 文件数据block的位置
```

表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。

目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。

Unix/Linux系统允许，多个文件名指向同一个inode号码。

```shell
ln 源文件 目标文件
ln 3.txt 4.txt 这是硬链接，相当于复制，不可以跨分区，但修改3,4会跟着变，若删除3,4不受任何影响。
```

文件A和文件B的inode号码虽然不一样，但是**文件A的内容是文件B的路径**。

```shell
ln -s 源文件 目标文件
ln -s 3.txt 4.txt 这是软连接，相当于快捷方式。修改4,3也会跟着变，若删除3,4就坏掉了。不可以用了。
```



```shell
磁盘IO性能检测{

        iostat -x 1 10

        % user       # 显示了在用户级(应用程序)执行时生成的 CPU 使用率百分比。
        % system     # 显示了在系统级(内核)执行时生成的 CPU 使用率百分比。
        % idle       # 显示了在 CPU 空闲并且系统没有未完成的磁盘 I/O 请求时的时间百分比。
        % iowait     # 显示了 CPU 空闲期间系统有未完成的磁盘 I/O 请求时的时间百分比。

        rrqm/s       # 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
        wrqm/s       # 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
        r/s          # 每秒完成的读 I/O 设备次数。即 delta(rio)/s
        w/s          # 每秒完成的写 I/O 设备次数。即 delta(wio)/s
        rsec/s       # 每秒读扇区数。即 delta(rsect)/s
        wsec/s       # 每秒写扇区数。即 delta(wsect)/s
        rkB/s        # 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)
        wkB/s        # 每秒写K字节数。是 wsect/s 的一半。(需要计算)
        avgrq-sz     # 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)
        avgqu-sz     # 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
        await        # 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
        svctm        # 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
        %util        # 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)

        IO性能衡量标准{

            1、 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
            2、 idle 小于70% IO压力就较大了,一般读取速度有较多的wait.
            3、 同时可以结合 vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)
            4、 svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了),svctm 的大小一般和磁盘性能有关,CPU/内存的负荷也会对其有影响,请求过多也会间接导致 svctm 的增加. await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式. 如果 svctm 比较接近 await,说明 I/O 几乎没有等待时间;如果 await 远大于 svctm,说明 I/O 队列太长,应用得到的响应时间变慢,如果响应时间超过了用户可以容许的范围,这时可以考虑更换更快的磁盘,调整内核 elevator 算法,优化应用,或者升级 CPU
            5、 队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。

        }

    }
```

```shell
iotop{

        # 监视进程磁盘I/O

        yum install iotop

        -o        # 只显示有io操作的进程
        -b        # 批量显示，无交互，主要用作记录到文件。
        -n NUM    # 显示NUM次，主要用于非交互式模式。
        -d SEC    # 间隔SEC秒显示一次。
        -p PID    # 监控的进程pid。
        -u USER   # 监控的进程用户。

        # 左右箭头：改变排序方式，默认是按IO排序。
        r         # 改变排序顺序。
        o         # 只显示有IO输出的进程。
        p         # 进程/线程的显示方式的切换。
        a         # 显示累积使用量。
        q         # 退出。

    }

```



```shell
新硬盘挂载{

        fdisk /dev/sdc
        p    #  打印分区
        d    #  删除分区
        n    #  创建分区，（一块硬盘最多4个主分区，扩展占一个主分区位置。p主分区 e扩展）
        w    #  保存退出
        mkfs.ext4 -L 卷标  /dev/sdc1            # 格式化相应分区
        mount /dev/sdc1  /mnt                  # 挂载
        vi /etc/fstab                          # 添加开机挂载分区
        LABEL=/data            /data                   ext4    defaults        1 2      # 用卷标挂载
        /dev/sdb1              /data4                  ext4    defaults        1 2      # 用真实分区挂载
        /dev/sdb2              /data4                  ext4    noatime,defaults        1 2

        第一个数字"1"该选项被"dump"命令使用来检查一个文件系统应该以多快频率进行转储，若不需要转储就设置该字段为0
        第二个数字"2"该字段被fsck命令用来决定在启动时需要被扫描的文件系统的顺序，根文件系统"/"对应该字段的值应该为1，其他文件系统应该为2。若该文件系统无需在启动时扫描则设置该字段为0
        当以 noatime 选项加载（mount）文件系统时，对文件的读取不会更新文件属性中的atime信息。设置noatime的重要性是消除了文件系统对文件的写操作，文件只是简单地被系统读取。由于写操作相对读来说要更消耗系统资源，所以这样设置可以明显提高服务器的性能.wtime信息仍然有效，任何时候文件被写，该信息仍被更新。

        mount -a    # 自动加载 fstab 文件挂载，避免配置错误，系统无法重启

    }
```

## 用户

```shell
users                                      # 显示所有的登录用户
groups                                     # 列出当前用户和他所属的组
who -q                                     # 显示所有的登录用户
groupadd                                   # 添加组
useradd user                               # 建立用户
passwd username                            # 修改密码
userdel -r                                 # 删除帐号及家目录
chown -R user:group                        # 修改目录拥有者(R递归)
umask                                      # 设置用户文件和目录的文件创建缺省屏蔽值
chgrp                                      # 修改用户组
echo "xuesong" | passwd user --stdin       # 非交互修改密码
useradd -g www -M  -s /sbin/nologin  www   # 指定组并不允许登录的用户,nologin允许使用服务
useradd -g www -M  -s /bin/false  www      # 指定组并不允许登录的用户,false最为严格
useradd -d /data/song -g song song         # 创建用户并指定家目录和组
usermod -l newuser olduser                 # 修改用户名
usermod -g user group                      # 修改用户所属组
usermod -d dir -m user                     # 修改用户家目录
usermod -G group user                      # 将用户添加到附加组
gpasswd -d user group                      # 从组中删除用户
su - user -c " #cmd1; "                    # 切换用户执行
```



```shell
特殊权限{

        s或 S （SUID）：对应数值4
        s或 S （SGID）：对应数值2
        t或 T ：对应数值1
        大S：代表拥有root权限，但是没有执行权限
        小s：拥有特权且拥有执行权限，这个文件可以访问系统任何root用户可以访问的资源
        T或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件

    }
    
chmod 4755 test  //使test文件具有SUID权限（4为SUID）。SUID对目录是无效的 
chmod 2755 test  //使test文件具有SGID权限（2为SGID）。SGID可用于文件或目录 
chmod 1755 /test  //使/test目录具有SBIT权限（1为Sticky bit即SBIT）。SBIT只对当前目录有效 
chmod 7666 test  //test文件拥有者无执行权限，设置后的大写S、T表示“空的”，即没有执行权限
chmod 765 111 //为111文件的属主设为完全权限，属组设成读写权，其它用户具有读和执行权限 
chmod a-r 111 //将111文件所有用户撤消读取权限 
chmod g+x 111 //将111文件属组增加执行权限
chmod o+r 111 //将111文件其它用户增加读取权限 
chmod u+w 111 //将111文件属主增加可写权限 
chmod g-r,o-r 111  //去掉文件111的同组和其他用户的读权限 
chmod o=rwx 111  //重设文件111的其他用户权限为读、写执行
chmod u+s /bin/file1  //设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 
chmod u-s /bin/file1  //禁用一个二进制文件的 SUID位 
chmod g+s /home/public  //设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 
chmod g-s /home/public  //禁用一个目录的 SGID 位 
chmod o+t /home/public  //设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 
chmod o-t /home/public  //禁用一个目录的 STIKY 位

chown -R ow2003 wxr  //更改目录wxr属于用户ow2003
chown :benet 222 //更改文件222属于组benet 
chown st03 222 //更改文件222属于用户st03 
chown st03:benet 222 //更改文件222属于用户st03组benet
```

