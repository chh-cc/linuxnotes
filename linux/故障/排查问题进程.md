

问题进程常见类型：

![image-20210714140413535](https://gitee.com/c_honghui/picture/raw/master/img/20210714140413.png)

前面 4 个类型可以总结为对资源使用过度，主要是 CPU、内存、 IO 以及对操作系统上文件句柄使用过度。会影响到业务服务的**稳定运行**

常见原因：

- 由于外部请求或外部访问，超过了自身进程所能够承载的负荷，导致系统的资源消耗过多；


- 进程内部的问题，即进程的程序代码设计不合理，效率比较低，出现了资源分配不合理的地方，导致在自己的资源上消耗过多；


- 部署不合理，比如我们在部署的时候，两个进程抢占同一份资源；


- 安全性的问题，比如被攻击等。



第二类问题：进程状态问题，常见问题进程状态：僵尸状态（Z）和不可中断的睡眠状态（D）

这一类的问题通常是**进程本身造成**的，代码逻辑导致的情况居多。

进程分析命令：

![image-20210714150840692](https://gitee.com/c_honghui/picture/raw/master/img/20210714150841.png)

查找进程 CPU 资源使用过度的场景：

- 使用top命令，按P对 CPU 的利用率由大到小进行排序

- 通过 ps -aux --sort=-%cpu 这个参数，我们同样也可以实现按照 CPU 的使用率，由大到小进行排序。

- 相对于 top 命令而言，ps 命令的优势在于它本身不会占用操作系统太多资源

内存使用过度：

- top，按M
- ps -aux --sort=-%MEN

IO资源过度：

yum install  sysstat

![image-20210714152204217](https://gitee.com/c_honghui/picture/raw/master/img/20210714152204.png)

僵尸进程：

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”

ps -ef |grep “defunct” 就会展示所有僵尸状态的进程。

ps -e -o ppid,stat | grep Z | cut -d” ” -f2 | xargs kill -9 处理僵尸进程，原理是要把父进程的 pid 清理掉，才能够把僵尸进程回收

进程不可中断睡眠状态：

可中断睡眠状态通常是以“S”表示，而不可中断睡眠状态通常是以“D”关键字符进行表示。

![image-20210714153335578](https://gitee.com/c_honghui/picture/raw/master/img/20210714153335.png)

我们会看到这里有两个进程，分别是进程 A 和进程 B，中间是一个队列，进程 B 负责添加数据，添加完数据以后，它要唤醒进程 A 来提取数据，并且执行相应的任务。假设在 B 唤醒 A 的过程中，A 进程正在处理上一次的任务，此时 A 就无法响应 B 的这次唤醒，这个时候就会导致进程 A 进入等待状态，从而进入不可中断的睡眠状态。



可中断的程序设计过程是这样的，它会只等待某个条件为真，不论是产生硬件中断，或释放进程等待系统资源，还是传递一个信号量，都可以作为唤醒进程的条件。而不可中断进程只能等待原有硬件终端所需要的资源被唤醒，如果没有得到唤醒的话，那么它就不响应操作系统上的信号量。




所以如果我们想关闭不可中断进程状态的话，通过 kill -9 命令关闭是做不到的。这种情况下，只能通过重启操作系统进行恢复或者所需资源。



再举一个真实的例子，我们常见到的客户端挂载 NFS 这种共享存储服务来给到客户端场景。假设把NFS 服务端关闭之时，未先 umount 相关目录，在 NFS 客户端执行 df 命令，这个时候我们会看到在操作系统的前端， df 命令会一直进入不可中断的状态，即使用 kill -9 也无法把 df 命令关闭。这时正确的处理方式是，需要先把 NFS 服务端的服务重新启用，才能够唤醒前端进程的响应，这个是我们常见到的一种情况。