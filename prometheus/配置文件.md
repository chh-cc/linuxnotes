# 配置文件

[Configuration | Prometheus](https://prometheus.io/docs/prometheus/latest/configuration/configuration/)

检查配置文件是否正确：`./promtool check config prometheus.yml`

重新加载配置：`kill -hup 进程id`

## 全局配置文件

```yaml
vim prometheus.yml
global:
	scrape_interval:     15s	#每隔15秒采集一次数据，默认1m
	evaluation_interval: 15s	#记录规则和报警规则的执行间隔（频率），默认1m
	scrape_timeout: 15s	#采集数据的超时时间，该值不能大于scrape_interval的值，默认10s。

#告警规则（比如cpu超过多少发送告警）
rule_files:
    ...
    
#配置被监控端，称为target，每个target用job_name分组管理，又分静态配置和服务发现
scrape_configs:
    ...
    
#告警配置
alerting:
    ...
    
#从远程数据库读写
remote_write:
    ...
remote_read:
    ...
```

## scrape_configs

```yaml
#采集对象的作业名称
job_name: <job_name>

#默认继承全局配置global，在这指定局部配置会覆盖全局配置
[ scrape_interval: 15s ]
[ scrape_timeout: 15s ]
[ metrics_path: /metrics ] #指标路径
[ honor_labels: <boolean> | default = false ] #标签

#目标拉取协议
[ scheme: <scheme> | default = http ]

#参数
params:
  [ <string>: [<string>, ...] ]

#基础认证
basic_auth:
  [ username: <string> ]
  [ password: <secret> ]
  [ password_file: <string> ]
tls_config:
  [ <tls_config> ]
[ proxy_url: <string> ]

#设置多种服务发现，最常见有以下两种方式
## 基于文件的服务发现提供了一种更通用的方法来配置静态目标，并充当插入自定义服务发现机制的接口(文件可以YAML或JSON格式提供,格式样例看下面的tips)
file_sd_configs:
  - files:
    - my/path/tg_*.json
    [ refresh_interval: <duration> | default = 5m ] # 该静态文件刷新时间间隔
# 基于kubernetes的服务发现,允许从 Kubernetes REST API 拉取集群pod相关信息并时刻保持同步。
kubernetes_sd_configs:
  [ - <kubernetes_sd_config> ... ]
...

#指定静态目标
static_configs:
  - target: ['localhost:9090','localhost:9191']
    labels:
        [ <labelname>: <labelvalue> ... ]
        
#重新标记  
relabel_configs:
  ...
  
metric_relabel_configs:
  ...
  
[ sample_limit: <int> | default = 0 ]
```

## relabel_configs

允许在采集之前对任何目标及其标签进行修改

隐藏标签：

```shell
__address__            被抓取目标的地址
__scheme__            抓取目标的请求模式，包括 http 与 https，默认为 http。
__metrics_path__    表示用于采集指标的 HTTP 路径，默认为 /metrics。
__param_<name>   包含 HTTP 查询参数名称和它们的值。
```

relabel规则组成：

```yaml
relabel_configs:
  #执行的relabeling动作
  [ action: <relabel_action> | default = replace ]
  #源标签，使用配置的分隔符串联的标签名称列表，并与提供的正则表达式进行匹配
  [ source_labels: '[' <labelname> [, ...] ']' ]
  #分隔符，用于在连接源标签source_labels时分割它们
  [ separator: <string> | default = ; ]
  #目标标签，当使用replace或者hashmod动作时，应该被覆盖的标签名
  [ target_label: <labelname> ]
  #正则表达式，用于匹配串联的源标签
  [ regex: <regex> | default = (.*) ]
  #取源标签值散列的模数
  [ modulus: <int> ]
  #如果正则表达式匹配，则对其执行正则表达式替换的替换值
  [ replacement: <string> | default = $1 ]
```

relabel的action动作：

```yaml
replace：默认，通过regex匹配source_label的值，然后集合目标标签到replacement，具有匹配组引用（$1,$2,...）在替换被它们的值所取代
keep：删除regex不匹配的目标source_label
drop：删除regex匹配的目标source_label
labeldrop：删除regex匹配的标签
labelkeep：删除regex不匹配的标签
hashmod：设置target_label为modulus连接的哈希值source_labels
labelmap：匹配regex所有标签名称，然后复制匹配标签的值进行分组
```