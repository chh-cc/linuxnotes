# Nginx概念

## 应用场景

作为 Web 服务器

作为负载均衡服务器

作为邮件代理服务器

## Nginx VS Apache

- 轻量级，同样起web 服务比Apache 占用更少的内存及资源

- 静态处理，Nginx 静态处理性能比 Apache 高 3倍以上

- 抗并发，Nginx 处理请求是**异步非阻塞**的，而Apache则是阻塞型的。在高并发下Nginx 能保持低资源低消耗高性能。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出Apache进程数飙升，从而拒绝服务的现象。

- 高度模块化的设计，编写模块相对简单

- 社区活跃，各种高性能模块出品迅速

## Nginx进程模型

<img src="https://gitee.com/c_honghui/picture/raw/master/img/20210302233050.png" alt="image-20210302233043576" style="zoom: 50%;" />

- 多进程：一个 Master 进程、多个 Worker 进程。
- Master 进程：**管理 Worker 进程**。对外接口：接收外部的操作（信号）；对内转发：根据外部的操作的不同，通过信号管理 Worker；监控：监控 Worker 进程的运行状态，Worker 进程异常终止后，自动重启 Worker 进程。
- Worker 进程：所有 Worker 进程都是平等的。实际处理：**网络请求**，由 Worker 进程处理。Worker 进程数量：在 nginx.conf 中配置，一般设置为核心数，充分利用 CPU 资源，同时，避免进程数量过多，避免进程竞争 CPU 资源，增加上下文切换的损耗。

**HTTP 连接建立和请求处理过程**

- Nginx 启动时，Master 进程，加载配置文件。
- Master 进程，初始化监听的 Socket。
- Master 进程，Fork 出多个 Worker 进程。
- Worker 进程，竞争新的连接，获胜方通过三次握手，建立 Socket 连接，并处理请求。

## Nginx 高性能、高并发

- Nginx 采用多进程+异步非阻塞方式（IO 多路复用 Epoll）。
- 请求的完整过程：建立连接→读取请求→解析请求→处理请求→响应请求。
- 请求的完整过程对应到底层就是：读写 Socket 事件。

I/O多路复用

## Nginx命令

```shell
nginx -c /path/to/nginx.conf  	  # 以特定目录下的配置文件启动nginx:
nginx -s reload            	 	 	  # 修改配置后重新加载生效
nginx -s reopen   			 	 				# 重新打开日志文件
nginx -s stop  				 	 	 				# 快速停止nginx
nginx -s quit  				  	 				# 完整有序的停止nginx
nginx -t    					 		 				# 测试当前配置文件是否正确
nginx -t -c /path/to/nginx.conf   # 测试特定的nginx配置文件是否正确
```

## curl命令

当部署、变更完一个站点后，首先应该分析服务端状态，那先从进程开始：

我们查看进程是不是启动的？是不是存在的？

进程存在状态是否正常，是 running 的状态还是进入了死锁的状态？

另外，我们可以通过它对 CPU 等资源使用率去分析这个进程是否属于正常范围，还可以通过日志去分析它的错误信息。

在分析完进程状态都是正常后，接下来我们就需要去了解，为什么从客户端访问服务端会有问题？

首先，就要从底层的网络开始排查 ，你的网络状态是否可以 ping 通，第二点，建立 TCP 连接是否正常？这个时候我们可以通过 Telnet 或者 TCPdump 等方式去进行抓包或分析。

鉴定网络状态正常后，再往上层也就是应用层寻找问题，如果网站为 HTTP\HTTPS Web服务，那我们就需要模拟 HTTP 请求到服务端，去判断服务端返回的头信息和 body 信息是不是符合我们的预期，这个时候就需要用到相关的工具去进行分析了。Curl 命令就在这个过程中起到非常好的作用。

加一个 -I 选项，就会看到服务端返回的相关头信息，这里面有很多 response head 信息，比如说 HTTP 的协议类型是 1.1，服务端状态码是 200，表示服务端返回正常。同时看到服务端返回的数据长度、类型以及缓存的头信息。

这里请求我的博客地址 URL（命令：curl www.jesonc.com），会发现并没有默认的 body 数据返回。为什么呢？因为服务端返回来一些重定向类型的状态码，比如 301、302 的这种重定向，是没有 body 数据的，只会返回头信息，所以我们可以先看头信息的内容。

在这个时候，如果想更加全面地了解整个通信过程，可以加一个 -v （命令：curl www.jesonc.com）参数。你可以看到请求服务端是不是已经发送出去了？并可以看到客户端发送的请求内容是什么，另外是看到服务端返回的情况，加 -v 的参数的作用就是可以把整个通信过程都打印出来。

![image-20210304000904160](https://gitee.com/c_honghui/picture/raw/master/img/20210304000904.png)

返回状态码在 100~199 之间，代表服务端是正常给到了一个信息响应，但没有完全建立起一次完整 HTTP 请求响应。



200~299 表示成功响应，看到这个状态码，可以认为服务端处理这次请求是正常的。



300~399 表示重定向，比如说 301、302 这些常见的重定向的状态码。



如果是 400 以上，说明客户端的请求方式得不到正常响应，那我们就需要具体去分析它的状态码，常见如 403、404、499、400 等相关的这些错误代码。你如果不了解，可以把错误代码在百度或者 Google 中搜索查看代表的是什么意思。



500+ 一般是服务端的程序或者逻辑相关的一些服务响应出现问题。