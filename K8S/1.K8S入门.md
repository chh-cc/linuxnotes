# K8S入门

Kubernetes是一个**开源的容器管理平台**，简称k8s，用于管理多个主机上的容器化应用程序，提供应用程序的快速部署，扩缩容，升级，维护和扩展等机制，利用service可以实现服务注册、发现以及四层负载均衡，通过ingress可以实现七层负载均衡等功能，Kubernetes这个名字源于希腊语，意思是舵手或飞行员

## 官网

https://kubernetes.io/

每年可能会发布三次版本，可以去官网或github的changelog查看更新信息

查看1.20.0的changelog：https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md#changelog-since-v1190

虽然K8s 1.20版本宣布将在1.23版本之后将不再维护dockershim，意味着K8s将不直接支持Docker，不过大家不必过于担心。一是在1.23版本之前我们仍然可以使用Docker，二是dockershim肯定会有人接盘，我们同样可以使用Docker，三是Docker制作的镜像仍然可以在其他Runtime环境中使用

## k8s高可用架构

简介版k8s架构图：

![第1关 K8s一窥真容](D:%5Clinuxnotes%5CK8S%5C1.K8S%E5%85%A5%E9%97%A8.assets%5Ce67659dc0f77424a8c0574f8a98c4fcc)


整个k8s集群分为两大部分：

- **控制平面/master节点**：负责控制并保持整个集群的正常运转，一般包括**controller plane的apiserver、controller-manager、scheduler、etcd**（如果磁盘 IO 、网络依赖较高，建议独立部署etcd）。公司生产环境**最少三台Master节点做高可用**，一般资源一次性给够，因为改动麻烦
  - kube-apiserver：它是**资源增删查改操作的唯一入口**，各个组件通过apiserver进行通信：各个组件通过apiserver将信息存入etcd，当要获取这些信息的时候再通过apiserver的REST接口（用get、watch、list）去请求
  - kube-controller-manager：**负责维护集群的状态**，执行各种控制器，比如故障检测、自动扩展、滚动更新，保证Pod或其他资源达到期望值
  - kube-scheduler：**负责调度**，它会根据指定的调度规则，把pod调度到一个或一批最佳的node节点
  - etcd：**保存了整个集群的状态**，一般生产环境建议部署3个以上奇数个节点（防止脑裂），规模大的话跟master分开，要用ssd盘，一般资源一次性给够，etcd备份：https://github.com/kubesphere/kubekey/blob/235de693d6e68740b573362b8fd3e1226d8c574f/pkg/etcd/templates/backup_script.go

- **工作节点/Node节点**：运行容器的任务依赖于每个工作节点上运行的组件。理论上一个k8s集群可以运行5000个节点，但是节点太多master负担也大，一般100~200个节点就够了；或者用公有云的全托管集群，master节点是公有云提供的，非常大，这样一个集群上千个节点是没问题的
  - Kubelet：负责容器真正运行的核心组件。负责node节点上pod的创建、修改、删除等全生命周期管理，定期汇报node状态给apiserver，通过apiserver间接与etcd交互读取集群配置信息。
  - Kube-proxy：kube-proxy负责转发，一旦发现service关联的某个pod信息发生变化，就会把这些变化转换成ipvs规则，完成对后端pod的负载均衡
  - 容器运行时：Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）

**附加组件**：

- CNI容器网络接口插件：calico, flannel（如果没有实施网络策略的需求，那么就直接用flannel，开箱即用；否则就用calico了，但要注意如果网络使用了巨型帧，那么注意calico配置里面的默认值是1440，需要根据实际情况进行修改才能达到最佳性能）
- CoreDNS：CoreDNS负责为整个集群提供DNS服务
- Ingress控制器：Ingress Controller为服务提供外网流量入口
- 容器集群监控：Metrics-server为K8s资源指标获取工具

## k8s核心功能全景图

<img src="D:%5Clinuxnotes%5CK8S%5C1.K8S%E5%85%A5%E9%97%A8.assets%5Cimage-20220527235230530.png" alt="image-20220527235230530" style="zoom: 67%;" />

首先从容器最基础的概念出发，遇到了容器间的“紧密协作”关系难题，于是有了pod；然后我们希望一次能启动多个应用实例，于是有了deployment；有了一组相同的pod后，我们需要一个固定ip和端口号以负载均衡的方式访问它们，于是有了service；

如果两个pod之间不仅有访问关系，还要密码认证，于是有了secret来保存认证信息挂载到容器里；

关于应用运行的形态，k8s基于pod定义了新的对象，比如job，一次性运行的pod；比如daemonset，每个宿主机必须且只能运行一个副本的守护进程；比如cronjob，做定时任务等。

在 Kubernetes 项目中，我们所推崇的使用方法是：

首先，通过一个“编排对象”，比如 Pod、Job、CronJob 等，来描述你试图管理的应用；

然后，再为它定义一些“服务对象”，比如 Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能。这种使用方法，就是所谓的“声明式 API”。这种 API 对应的“编排对象”和“服务对象”，都是 Kubernetes 项目中的 API 对象（API Object）。

这就是 Kubernetes 最核心的设计理念。

## 集群安装比较

| 工具      | 方法                                                         | 优点                                                         | 缺点                                                 |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
| 二进制    | 下载二进制文件，通过systemd来管理                            | 灵活度强                                                     | 复杂，需要关心每个组件的配置，对系统服务的依赖性过多 |
| kubeadm   | 搭建集群的命令行工具，管理节点通过kubeadm init初始化，计算节点通过kubeadm join加入 | 相对二进制，控制面板组件的安装和配置被封装起来；管理集群生命周期，比如证书、升级 | 操作系统层面配置还需手动，CNI插件还需手动            |
| kubespray | 通过ansible-playbook搭建                                     | 自动完成操作系统层面配置，用kubeadm管理集群                  | 缺少基于声明式API的支持                              |
| KOPS      | 基于声明式API的集群管理工具                                  | 基于Cluster API进行集群管理，节点的操作系统安装等全是自动化  | 与云环境深度集成灵活性差                             |

## YAML

k8s把需要操作的资源对象编辑到yaml文件中。

yaml基本语法：

- 使用空格做为缩进
- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
- 使用#标识注释，从这个字符一直到行尾，都会被解释器忽略
- ---表示开始新的yaml文件

数据结构：

- 对象

```yaml
name: Tom
age: 18
```

- 数组

```yaml
people
- Tom
- Jack
```

- 纯量

```yaml
数值
number: 12.3

布尔值
isset: true

null用~表示

字符串默认不用引号，除非字符串中间包括空格或特殊字符

多行字符串可以用|保留换行符
this: |
too
bar
```

