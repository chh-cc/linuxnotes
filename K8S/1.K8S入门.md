# K8S入门

Kubernetes是一个**开源的容器管理平台**，简称k8s，用于管理多个主机上的容器化应用程序，提供应用程序的快速部署，扩缩容，升级，维护和扩展等机制，利用service可以实现服务注册、发现以及四层负载均衡，通过ingress可以实现七层负载均衡等功能，Kubernetes这个名字源于希腊语，意思是舵手或飞行员

## 官网

https://kubernetes.io/

每年可能会发布三次版本，可以去官网或github的changelog查看更新信息

查看1.20.0的changelog：https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md#changelog-since-v1190

虽然K8s 1.20版本宣布将在1.23版本之后将不再维护dockershim，意味着K8s将不直接支持Docker，不过大家不必过于担心。一是在1.23版本之前我们仍然可以使用Docker，二是dockershim肯定会有人接盘，我们同样可以使用Docker，三是Docker制作的镜像仍然可以在其他Runtime环境中使用

## 为什么用k8s

随着项目越来越多，管理的容器越来越多，裸容器部署的方式越来越难管理

特点：

**服务发现与负载均衡**

**强大的自动修复能力**

**服务滚动升级**

**水平扩缩容**

## k8s高可用架构

![img](https://gitee.com/c_honghui/picture/raw/master/img/20220307145849.png)



**master节点**：它的主要职责是调度，即决定将应用放在哪里运行，一般包括**controller plane的apiserver、controller-manager、scheduler、etcd**（如果磁盘 IO 、网络依赖较高，建议独立部署etcd），它们都需要和etcd进行交互以存储数据。公司生产环境**最少三台Master节点做高可用**，一般资源一次性给够，因为改动麻烦：

- kube-apiserver：负责 API 服务，所有的请求都需要经过这个接口进行通信，它是资源增删查改操作的唯一入口，并提供认证、授权、访问控制等机制
- kube-controller-manager：负责容器编排，检查pod的健康状态，比如故障检测、自动扩展、滚动更新，保证Pod或其他资源达到期望值
- kube-scheduler：负责调度，它会根据指定的调度规则，把pod调度到一个或一批最佳的node节点

**Etcd**：键值数据库，保存整个kubernetes集群的状态，一般生产环境建议部署3个以上奇数个节点（防止脑裂），规模大的话跟master分开，要用ssd盘，一般资源一次性给够，etcd备份：https://github.com/kubesphere/kubekey/blob/235de693d6e68740b573362b8fd3e1226d8c574f/pkg/etcd/templates/backup_script.go

**Node节点**：一般为work节点，容器运行的地方。理论上一个k8s集群可以运行5000个节点，但是节点太多master负担也大，一般100~200个节点就够了；或者用公有云的全托管集群，master节点是公有云提供的，非常大，这样一个集群上千个节点是没问题的

- Kubelet：计算节点最核心的组件，**主要负责和container runtime打交道**，而这个交互所依赖的，是一个称作 CRI（Container Runtime Interface）的远程调用接口，这个接口定义了容器运行时的各项核心操作，比如：启动一个容器需要的所有参数。而 kubelet 的另一个重要功能，则是**调用网络插件和存储插件为容器配置网络和持久化存储**。这两个插件与 kubelet 进行交互的接口，分别是 CNI（Container Networking Interface）和 CSI（Container Storage Interface）。
- Kube-proxy：是在每个节点上运行的网络代理，kube-proxy负责转发，一旦发现service关联的某个pod信息发生变化，就会把这些变化转换成ipvs规则，完成对后端pod的负载均衡

Calico：符合CNI标准的网络插件，给每个Pod生成一个唯一的IP地址，并且把每个节点当作一个路由器

CoreDNS：用于k8s集群内部Service的解析

## k8s核心功能全景图

<img src="https://gitee.com/c_honghui/picture/raw/master/img/20220323161914.webp" alt="img" style="zoom:67%;" />

首先从容器最基础的概念出发，遇到了容器间的“紧密协作”关系难题，于是有了pod；然后我们希望一次能启动多个应用实例，于是有了deployment；有了一组相同的pod后，我们需要一个固定ip和端口号以负载均衡的方式访问它们，于是有了service；

如果两个pod之间不仅有访问关系，还要密码认证，于是有了secrety来保存认证信息挂载到容器里；

关于应用运行的形态，k8s基于pod定义了新的对象，比如job，一次性运行的pod；比如daemonset，每个宿主机必须且只能运行一个副本的守护进程；比如cronjob，做定时任务等。

在 Kubernetes 项目中，我们所推崇的使用方法是：

首先，通过一个“编排对象”，比如 Pod、Job、CronJob 等，来描述你试图管理的应用；

然后，再为它定义一些“服务对象”，比如 Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能。这种使用方法，就是所谓的“声明式 API”。这种 API 对应的“编排对象”和“服务对象”，都是 Kubernetes 项目中的 API 对象（API Object）。

这就是 Kubernetes 最核心的设计理念。

## 集群安装比较

| 工具      | 方法                                                         | 优点                                                         | 缺点                                                 |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
| 二进制    | 下载二进制文件，通过systemd来管理                            | 灵活度强                                                     | 复杂，需要关心每个组件的配置，对系统服务的依赖性过多 |
| kubeadm   | 搭建集群的命令行工具，管理节点通过kubeadm init初始化，计算节点通过kubeadm join加入 | 相对二进制，控制面板组件的安装和配置被封装起来；管理集群生命周期，比如证书、升级 | 操作系统层面配置还需手动，CNI插件还需手动            |
| kubespray | 通过ansible-playbook搭建                                     | 自动完成操作系统层面配置，用kubeadm管理集群                  | 缺少基于声明式API的支持                              |
| KOPS      | 基于声明式API的集群管理工具                                  | 基于Cluster API进行集群管理，节点的操作系统安装等全是自动化  | 与云环境深度集成灵活性差                             |

## YAML

k8s把需要操作的资源对象编辑到yaml文件中。

yaml基本语法：

- 使用空格做为缩进
- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
- 使用#标识注释，从这个字符一直到行尾，都会被解释器忽略
- ---表示开始新的yaml文件

数据结构：

- 对象

```yaml
name: Tom
age: 18
```

- 数组

```yaml
people
- Tom
- Jack
```

- 纯量

```yaml
数值
number: 12.3

布尔值
isset: true

null用~表示

字符串默认不用引号，除非字符串中间包括空格或特殊字符

多行字符串可以用|保留换行符
this: |
too
bar
```

