# ConfigMap和Secret

## configmap

让镜像 和 配置文件解耦，一般用于管理一些**配置文件**，或者一些大量的**环境变量**信息

### 通过file方式创建configmap

```shell
#把本地的nginx.conf创建为configmap
kubectl create cm nginx-conf --from-file=nginx.conf
kubectl get cm nginx-conf -oyaml
```

### 通过存储卷使用comfigmap

```yaml
kubectl edit deploy demo-nginx

sepc:
  template:
    spec:
      containers:
      - image: nginx
        volumeMounts: #挂载存储卷
        - name: config-volume #存储卷名称
          mountPath: /etc/nginx #容器挂载目录，该目录下生成nginx.conf文件
      volumes: #定义存储卷
      - name: config-volume #存储卷名称
        configMap: #存储卷类型
          name: nginx-conf #configmap名称
```

但是这样nginx.conf会覆盖容器/etc/nginx目录下的所有内容，解决办法是使用**SubPath**

```yaml
sepc:
  template:
    spec:
      containers:
      - image: nginx
        volumeMounts:
        - name: config-volume
          mountPath: /etc/nginx/nginx.conf
          subPath: etc/nginx/nginx.conf #
      volumes:
      - name: config-volume
        configMap:
          name: nginx-conf
          items:
          - key: nginx.conf #对应configMap中data下面的key值
            path: etc/nginx/nginx.conf #将容器中该文件名进行挂载
```

### 通过yaml方式创建configmap

定义configmap

```yaml
vim configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config #configmap名称
  namespace: default
data:
  special.how: very #键值对
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config
  namespace: default
data:
  log_level: INFO
```

创建configmap

```shell
kubectl create -f configmaps.yaml
```

### 通过环境变量引用configmap

```yaml
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: SPECIAL_LEVEL_KEY #pod中显示的变量名
          valueFrom:
            configMapKeyRef:
              name: special-config #引用configmap的名称
              key: special.how #引用configmap的键名称
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: env-config
              key: log_level
```

## Secret

用来保存敏感信息，比如密码、令牌或key、redis、mysql密码

secret类型：

- tls类型：专用ssl。tls格式的证书和私钥打包进secret中。不管原来文件叫什么，通通进行统一，证书一定会映射为叫tls.crt。私钥为tls.key
- generic：非证书认证时使用的普通的敏感信息类型
- docker-registry：用于连接dockerhub中时使用的账户认证信息类型

### 通过file方式创建secret

Secret 中可以包含 Pod 访问数据库时需要的用户凭证信息。可以将用户名和密码保存在本地机器的 `./username.txt` 和 `./password.txt` 文件里

```shell
# 创建本例中要使用的文件
echo -n 'admin' > ./username.txt
echo -n '1f2d1e2e67df' > ./password.txt
# 创建secret
kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
# 查看secret
kubectl get secrets
```

### 通过存储卷使用secret

```yaml
kubectl create secret tls nginx-ssl-secret --key=./nginx.key --cert=./nginx.crt

sepc:
  template:
    spec:
      containers:
      - image: nginx
        volumeMounts:
        - name: nginxcerts
          mountPath: /etc/nginx/certs/
      volumes:
      - name: nginxcerts
        secret:
          secretName: nginx-ssl-secret
```

### 通过yaml方式创建secret

```yaml
# 将字段转换为base64
echo -n 'admin' | base64
echo -n '1f2d1e2e67df' | base64
# 创建secret
vim ./secret.yaml

apiVersion: v1
kind: Secret
metadata:
  name: mysql-root-passwd #secret名称
type: Opaque
data:
  username: YWRtaW4= #键值对
  password: MWYyZDFlMmU2N2Rm
  
kubectl apply -f ./secret.yaml
```

### 通过环境变量引用secret

```yaml
#使用secret
spec:
  containers:
    - name: myapp
      image: docker.io/ikubernetes/myapp
      env:
        - name: SECRET_USERNAME #pod中显示的变量名
          valueFrom:
            secretKeyRef:
              name: mysql-root-passwd #引用secret的名称
              key: username #引用secret的键名称
        - name: SECRET_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-root-passwd
              key: password
```

### ImagePullSecret

kubectl拉取私有镜像仓库的镜像时使用的账号密码

创建一个docker registry的secret

```shell
kubectl create secret docker-registry docker-secret --docker-server=hub.docker.com --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD -docker-email=DOCKER_EMAIL
```

在创建pod中使用secret

```yaml
...
spec:
  imagePullSecrets:
  - name: docker-secret
...
```

## secret和configmap热更新

configmap和secret如果是以**subpath或env挂载**的话，那么pod不会感知到configmap和secret的更新的，**只有重启pod之后或者重新部署pod之后，修改的配置才会生效**。

其他方式可以通过`kubectl edit cm <configmap-name>``kubectl edit cm <secret-name>`来更新cm或secret，pod也会自动更新

## 不可变secret和configmap

添加immutable参数：

```yaml
kubectl edit cm xxx

...
immutable: true
```

添加后就无法编辑了
