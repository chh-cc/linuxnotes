# Volume

https://kubernetes.io/docs/concepts/storage/volumes/

pod是有生命周期的，重启它的文件会丢失、一个pod中运行多个容器可能需要共享一些文件、不同pod共享文件、日志收集

存储卷类型：

-    emptyDIR存储卷
-    hostPath存储卷 
-    SAN（iscsi）或NAS（nfs、cifs）： 网络存储设备
-    分布式存储（ceph,glusterfs,cephfs） 
-    云存储（亚马逊的EBS，Azure Disk，阿里云）： 这种是网络存储的，一般只有k8s在云上部署才会用到。

## hostpath

不推荐使用，将节点上的文件或目录挂载到pod上

## emptyDir

emptyDir 是最基础的 Volume 类型。正如其名字所示，一个 emptyDir Volume 是 Host 上的一个空目录。

如果删除pod，emptydir卷中的数据也会被删除，一般用于pod中不同容器**临时共享数据**

示例：

```yaml
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache #挂载到容器的/cache目录
      name: cache-volume
  volumes:
  - name: cache-volume #定义了一个emptyDir卷
    emptyDir: {}
```

## PV&PVC

PersistentVolume (PV)是外部存储系统中的一块存储空间，由管理员创建和维护。与 Volume 一样，PV 具有持久性，生命周期独立于 Pod，它是集群中的资源

PersistentVolumeClaim (PVC) 是对PV的申请，不需要关心具体的Volume实现细节

PV没有namespace概念，PVC有namespace隔离

<img src="https://gitee.com/c_honghui/picture/raw/master/img/20211219184540.png" alt="image-20211219184540755" style="zoom:80%;" />

### 静态PV

nfs搭建

```
yum install nfs-utils
 
vim /etc/exports
/data/k8s/ 172.16.1.0/24(sync,rw,no_root_squash)
 
systemctl start nfs; systemctl start rpcbind 
systemctl enable nfs

测试：
yum install nfs-utils
showmount -e 172.16.1.131
```

创建PV：

```yaml
vim nfs-pv.yaml

apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001 #pv名称
spec:
  capacity:
    storage: 2Gi #pv容量
  volumeMode: Filesystem #挂载类型
  accessModes:
    - ReadWriteMany #访问模式
  persistentVolumeReclaimPolicy: Retain #回收策略
  storageClassName: nfs-slow #类名
  mountOptions:
    - hard
    - nfsvers=4.1
  nfs:
    path: /tmp #存储路径
    server: 172.17.0.2 #nfs地址
    
kubectl get pv
NAME     CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
pv0001   2Gi        RWX            Retain           Available           nfs-slow                4s

#PV状态：
#Available：空闲的pv，没有被任何pvc绑定
#Bound：已经被pvc绑定
#Released：PVC被删除，但是资源未被重新使用
#Failed：自动回收失败
```

回收策略`persistentVolumeReclaimPolicy`：

- Recycle：删掉PVC，会rm -rf /thevolume/*将**PV里的内容删除**
- Retain：保留，删掉PVC后PV由Bound状态变为Released，此状态下的PV不能和别的PVC绑定，**删除PV后PV存储的内容还在**，可以重新创建PV和PVC绑定
- Delete：删除PVC后，对应的PV和存储内容也会被删掉

访问模式`accessModes`：

- ReadWriteOnce（RWO），该卷可以被单个节点以读写方式挂载 
- ReadOnlyMany（ROX），该卷可以被许多节点以只读方式挂载
- ReadWriteMany（RWX），该卷可以被多个节点以读写方式挂载

PV类名`storageClassName`：**PVC和PV的类名一样，才能被绑定**

创建PVC：

```yaml
vim nfs-pvc.yaml

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim #pvc名称
# namespace: 
spec:
  accessModes:
    - ReadWriteMany
  volumeMode: Filesystem
  resources:
    requests:
      storage: 1Gi
  storageClassName: nfs-slow
  
kubectl get pvc
NAME      STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myclaim   Bound    pv0001   2Gi        RWX            nfs-slow       4s
```

把pvc挂载到pod

```yaml
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /tmp/pvc #把pv卷挂载到容器的该目录
      name: pvc-test #pv卷名称
  volumes:
  - name: pvc-test #卷名称
    persistentVolumeClaim: #申明使用静态PVC永久化存储
      claimName: myclaim #pvc名称
```

创建PVC后一直绑定不上PV（pending）的原因：

- PVC的空间申请大小大于PV的容量
- PVC的StorageClassName和PV不一致
- PVC的accessModes和PV不一致

创建挂载了PVC的Pod后，一直处于pending状态的原因：

- PVC没有创建成功
- PVC和Pod不在同一个namespace

### 动态PV

当我们k8s业务上来的时候，大量的pvc,此时我们人工创建匹配的话，工作量就会非常大了，需要动态的自动挂载相应的存储

使用StorageClass来对接存储，靠他来自动关联pvc,并创建pv。

Kubernetes支持动态供给的存储插件： https://kubernetes.io/docs/concepts/storage/storage-classes/

定义一个storage

```yaml
apiVersion: storage.k8s.io/v1beta1
kind: StorageClass
metadata:
  name: managed-nfs-storage # StorageClass名称
provisioner: fuseim.pri/ifs # 默认不支持nfs存储，添加支持web插件标识
```

因为storage自动创建pv需要经过kube-apiserver,所以要进行授权

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner

---
#角色的权限
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: nfs-client-provisioner-runner
rules:
  - apiGroups: [""]
    resources: ["persistentvolumes"]
    verbs: ["get", "list", "watch", "create", "delete"]
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["list", "watch", "create", "update", "patch"]

---
#角色绑定
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: run-nfs-client-provisioner
subjects:
  - kind: ServiceAccount
    name: nfs-client-provisioner
    namespace: default
roleRef:
  kind: ClusterRole
  name: nfs-client-provisioner-runner
  apiGroup: rbac.authorization.k8s.io
```

创建nfs相关存储服务

```yaml
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      imagePullSecrets:
        - name: registry-pull-secret
      # 绑定自定义的sa
      serviceAccount: nfs-client-provisioner
      containers:
        # 镜像拉取
        - name: nfs-client-provisioner
          image: lizhenliang/nfs-client-provisioner:v2.0.0
          # 挂载存储
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              # 指定标识插件的值
              value: fuseim.pri/ifs
            - name: NFS_SERVER
              # nfs地址
              value: 192.168.1.115
            - name: NFS_PATH
              # 挂在路径
              value: /data/nfs
      volumes:
        - name: nfs-client-root
          nfs:
            # nfs地址
            server: 192.168.1.115
            # 共享路径
            path: /data/nfs
```

查看创建的storageclass

```shell
kubectl get storageclass
```

查看创建的nfs

```shell
kubectl get pods
```

部署mysql使用动态PV

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
    name: mysql
  # 创建service为无头服务，标识容器
  clusterIP: None
  selector:
    app: mysql-public

---

apiVersion: apps/v1beta1
kind: StatefulSet
# 名称
metadata:
  name: db
spec:
  # 指定service名称
  serviceName: "mysql"
  # 标签选择器
  template:
    metadata:
      labels:
        app: mysql-public
    spec:
      # 镜像容器编辑
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        # 创建数据库用户密码
        - name: MYSQL_ROOT_PASSWORD
          value: "123456"
        # 创建数据库
        - name: MYSQL_DATABASE
          value: test
        # 启用端口
        ports:
        - containerPort: 3306
        # 数据卷
        volumeMounts:
        # 挂在容器目录
        - mountPath: "/var/lib/mysql"
          # 使用来源
          name: mysql-data
      # 使用数据卷来源
      volumes:
      # 数据卷名称
      - name: mysql-data
        # 指定数据卷动态供给
        persistentVolumeClaim:
          # pvc动态供给名称
          claimName: mysql-pvc

---

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  # pvc名称
  name: mysql-pvc
spec:
  # 读写权限
  accessModes:
    - ReadWriteMany
  # 使用的存储类
  storageClassName: managed-nfs-storage
  # 定义容量
  resources:
    requests:
      storage: 5Gi
```

