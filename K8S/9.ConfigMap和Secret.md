# ConfigMap和Secret

## configmap

一般用于管理一些配置文件，或者一些大量的环境变量信息

让镜像 和 配置文件解耦，以便实现镜像的可移植性和可复用性

### 通过file方式创建configmap

```shell
#把本地的nginx.conf创建为configmap
kubectl create cm nginx-conf --from-file=nginx.conf
kubectl get cm
#把configmap挂载到deployment
kubectl edit deploy demo-nginx

sepc:
  template:
    spec:
      containers:
      - image: nginx
        volumeMounts:
        - name: config-volume
          mountPath: /etc/nginx 
      volumes:
      - name: config-volume
        configMap:
          name: nginx-conf
```

但是这样nginx.conf会覆盖容器/etc/nginx目录下的所有内容，解决办法是使用**SubPath**

```yaml
sepc:
  template:
    spec:
      containers:
      - image: nginx
        volumeMounts:
        - name: config-volume
          mountPath: /etc/nginx/nginx.conf
          subPath: etc/nginx/nginx.conf
      volumes:
      - name: config-volume
        configMap:
          name: nginx-conf
          items:
          - key: nginx.conf
            path: etc/nginx/nginx.conf
```

### 通过yaml方式创建configmap

定义configmap

```yaml
vim configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config
  namespace: default
data:
  log_level: INFO
```

创建configmap

```shell
kubectl create -f configmaps.yaml
```

在pod中定义环境变量

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: SPECIAL_LEVEL_KEY #pod中显示的变量名
          valueFrom:
            configMapKeyRef:
              name: special-config #引用configmap的名称
              key: special.how #引用configmap的键名称
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: env-config
              key: log_level
  restartPolicy: Never
```

## Secret

用来保存敏感信息，比如密码、令牌或key、redis、mysql密码

### 使用kubectl创建secret

Secret 中可以包含 Pod 访问数据库时需要的用户凭证信息。可以将用户名和密码保存在本地机器的 `./username.txt` 和 `./password.txt` 文件里

```shell
# 创建本例中要使用的文件
echo -n 'admin' > ./username.txt
echo -n '1f2d1e2e67df' > ./password.txt
# 创建secret
kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
# 查看secret
kubectl get secrets
```

### 手动创建secret

```yaml
# 将字段转换为base64
echo -n 'admin' | base64
echo -n '1f2d1e2e67df' | base64
# 创建secret
vim ./secret.yaml

apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
  
kubectl apply -f ./secret.yaml
```

### ImagePullSecret

kubectl拉取私有镜像仓库的镜像时使用的账号密码

创建一个docker registry的secret

```shell
kubectl create secret docker-registry docker-secret --docker-server=hub.docker.com --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD -docker-email=DOCKER_EMAIL
```

在创建pod中使用secret

```yaml
...
spec:
  imagePullSecrets:
  - name: docker-secret
...
```

## secret和configmap热更新

configmap和secret如果是以subpath挂载的话，那么pod不会感知到configmap和secret的更新的

如果pod的变量来自configmap和secret，那么更新configmap和secret后不会更新pod的变量

## 不可变secret和configmap

添加immutable参数：

```yaml
kubectl edit cm xxx

...
immutable: true
```

添加后就无法编辑了
