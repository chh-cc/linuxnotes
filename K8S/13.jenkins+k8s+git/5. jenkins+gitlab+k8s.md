基于k8s的cicd流程

CI：开发代码-->提交代码到gitlab-->jenkins拉取代码-->sonarqube代码扫描-->制作docker镜像并上传到-->部署在k8s测试环境

CD：jenkins pipeline发布到生产环境



一、拉取代码

**添加gitlab凭证：**

把jenkins宿主机的ssh公钥添加到gitlab，这样可以拉取任何项目的代码

jenkins创建gitlab凭证（把jenkins宿主机的私钥添加进去）

用pipeline语法生成器，生成拉取代码步骤的pipeline语法：

![image-20230514192654041](assets/image-20230514192654041.png)



```groovy
        stage('拉取代码') {
            steps {
                //引用参数化构建的分支、定义的gitlab凭证id、定义的项目地址
                checkout([$class: 'GitSCM', branches: [[name: '${params.Branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '${git_auth}', url: '${git_url}']]])
            }
        }
```

二、sonarqube扫描

```groovy
        stage('代码扫描') {
            steps {
                //下面的SonarQube-Server和系统配置SonarQube installations的Name必须一致, 大小写敏感
                withSonarQubeEnv("SonarQube-Server"){ 
                    //执行mvn的命令时使用SonarQube-Scanner检测代码
                    sh 'mvn sonar:sonar'
                }
            }
        }
```

三、制作镜像并上传到镜像仓库

**添加镜像仓库凭证**

```groovy
        stage('代码编译') {
            steps {
                sh """
                  mvn clean package -Dmaven.test.skip=true
                """
            }
        }

        stage('构建镜像') {
            steps {
                //通过凭证转换成阿里云镜像服务的账号和密码变量
                withCredentials([usernamePassword(credentialsId: "${registry_auth}", passwordVariable: 'password', usernameVariable: 'username')]) {
                    sh """
                        #登录镜像仓库
                        docker login -u ${username} -p '${password}' ${registry}
                        #制作和上传镜像
                        for service in \$(echo ${service} |sed 's/,/ /g');do
                            service_name=\${service%:*}
                            image_name=${registry}/${project}/\${service_name}:${BUILD_NUMBER}
                            cd \${service_name}
                            if ls |grep biz &>/dev/null;then
                                cd \${service_name}-biz
                            fi
                            docker build -t \${image_name} .
                            docker push \${image_name}
                            cd ${WORKSPACE}
                        done
                    """
				}
            }
        }
```

四、部署到k8s环境

在k8s中为用户admin授权，生成kubeconfig文件。或者直接复制/root/.kube/config（这是一个kubeconfig文件）

Jenkins-slave镜像已经有kubectl命令，只需要kubeconfig就可以连接k8s集群

把生成的kubeconfig文件放到Jenkins中：需要安装Config File Provider插件

将生成的kubeconfig文件内容复制进去，复制ID号，在pipeline脚本定义变量：def k8s_auth = "ID号"

<img src="assets/2347845-20220410142541035-1860790746.png" alt="img" style="zoom:50%;" />

```groovy
        stage('部署到k8s') {
            steps {
                withCredentials([usernamePassword(credentialsId: "${registry_auth}", passwordVariable: 'password', usernameVariable: 'username')]) {
                    sh """
                    
                    """
            }
        }
```



jenkinsfile

```groovy
#!/usr/bin/env groovy
//镜像仓库地址
def registry = "registry.cn-shenzhen.aliyuncs.com"
//项目名称
def project = ""
//项目地址
def git_url = ""
//服务域名
def gateway_domain_name = ""
def portal_domain_name = ""
//凭证id
def image_pull_secret = "registry-pull-secret"
def registry_auth = ""
def git_auth = ""
def k8s_auth = ""

pipeline {
    //动态创建slave
    agent {
      kubernetes {
          label "jenkins-slave"
          yaml """
kind: pod
metadata:
  name: jenkins-slave
spec:
  containers:
  - name: jnlp
    image: "${registry}//jenkins-slave-jdk:1.8"
    imagePullPolicy: Always
    volumeMounts:
    - name: docker-cmd
      mountPath: /usr/bin/docker
    - name: docker-sock
      mountPath: /var/run/docker.sock
    - name: maven-cache
      mountPath: /root/.m2
  volumes:
  - name: docker-cmd
    hostPath:
      path: /usr/bin/docker
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock
  - name: maven-cache
    hostPath:
      path: /tmp/m2
"""
      }
    }
    
    //参数化构建
    parameters {
        //git参数，从git地址获取分支，来选择发布的分支
        gitParameter branch: '', branchFilter: '.*', defaultValue: '', description: '选择发布的分支', name: 'Branch', quichFilterEnabled: false, selecteValue: 'NONE', sortMode: 'NONE', tagFilter: '*', type: 'PT_BRANCH'
        //extended choice，通过复选框来勾选要发布的微服务
        extendedChoice defaultValue: '', description: '选择发布的分支', multiSelectDelimiter: ',', name: 'Service', type: 'PT_CHECKBOX', value: 'gateway-service:9999,portal-service:8080,product-service:8010,order-service:8020,stock-service:8030'
        //choice
        choice choices: ['ms', 'demo'], description: '部署模板', name: 'Template'
        choice choices: ['1', '3', '5', '7'], description: '副本数', name: 'ReplicaCount'
        choice choices: ['ms'], description: '命名空间', name: 'Namespace'
    }


    stages {
        stage('拉取代码') {
            steps {
                //引用参数化构建的分支、定义的gitlab凭证id、定义的项目地址
                checkout([$class: 'GitSCM', branches: [[name: '${params.Branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '${git_auth}', url: '${git_url}']]])
            }
        }
        stage('代码编译') {
            steps {
                sh """
                  mvn clean package -Dmaven.test.skip=true
                """
            }
        }
        stage('构建镜像') {
            steps {
                //通过凭证转换成阿里云镜像服务的账号和密码变量
                withCredentials([usernamePassword(credentialsId: "${registry_auth}", passwordVariable: 'password', usernameVariable: 'username')]) {
                    sh """
                        #登录镜像仓库
                        docker login -u ${username} -p '${password}' ${registry}
                        #制作和上传镜像
                        for service in \$(echo ${service} |sed 's/,/ /g');do
                            service_name=\${service%:*}
                            image_name=${registry}/${project}/\${service_name}:${BUILD_NUMBER}
                            cd \${service_name}
                            if ls |grep biz &>/dev/null;then
                                cd \${service_name}-biz
                            fi
                            docker build -t \${image_name} .
                            docker push \${image_name}
                            cd ${WORKSPACE}
                        done
                    """
                    configfileProvider([configFile(fileId: "${k8s_auth}", targetLocation: "admin.kubeconfig")]){
                        sh """
                           #添加镜像拉取认证
                           kubectl create secret docker-registry ${image_pull_secret}
                           --docker-username=${username} --docker-password=${password}
                           --docker-server=${registry} -n ${Namespace} --kubeconfig
                           admin.kubeconfig |true
                           #添加私有chart仓库
                           helm repo add --username ${username} --password ${password}
                           myrepo http://${registry}/chartrepo/${project}
                        """
                    }
				}
            }
        }
        stage('Helm部署到k8s') {
            steps {
                sh """
                    common_args="-n ${Namespace} --kubeconfig admin.kubeconfig"
                    
                    for serivce in \$(echo ${Service} |sed 's/,/ /g');do
                        service_name=\${service%:*}
                        service_port=\${service#*:}
                        image=${registry}/${project}/\${service_name}
                        tag=${BUILD_NUMBER}
                        
                        #helm参数
                        helm_args="\{service_name} --set image.repository=\${image} --set image.tag=\${tag} --set replicaCount=${replicaCount} --set imagePullSecrets[0].name=${image_pull_secret} --set service.targetPort=\${service_port} myrepo/${Template}"
                        
                        #是否为新部署
                        if helm history \${service_name} \${common_agrs} &>/dev/null;then
                            action=upgrade
                        else
                            action=install
                        fi
                        
                        #针对服务启用ingress
                        if [ \${service_name} == "gateway-service" ];then
                            helm \${action} \${helm_args} \
                            --set ingress.enabled=true \
                            --set ingress.host=${gateway_domain_name} \
                            \${common_args}
                        elif [ \${service_name} == "portal-service" ];then
                            helm \${action} \${helm_args} \
                            --set ingress.enabled=true \
                            --set ingress.host=${portal_domain_name} \
                            \${common_args}
                        else
                            helm \${action} \${helm_args} \${common_args}
                        fi
                    done
                """
            }
        }
    }
}
```

