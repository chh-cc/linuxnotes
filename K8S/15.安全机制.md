# 安全机制

## 概述

API Server是集群内各个组件通信的中介，也是外部控制入口，所以k8s安全都是围绕API Server来设计。

k8s通过**认证（Authentication）、鉴权（Authoritarian）、准入控制（Admission Control）**来保证API Server的安全。

<img src="https://gitee.com/c_honghui/picture/raw/master/img/20220320151104.png" alt="image-20220320151056641" style="zoom:67%;" />

## 认证

对用户身份进行验证。认证方式现共有8种，可以启用一种或多种认证方式，只要有一种认证方式通过，就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。

### X509 Client Certs

X509 Client Certs（客户端证书认证），启用此认证方式是通过设置apiserver参数--client-ca-file=/etc/kubernetes/pki/ca.crt。当用户访问API时，apiserver使用/etc/kubernetes/pki/ca.crt（CA证书），通过TLS双向认证验证客户端证书是否由它签发。

```shell
cat /etc/kubernetes/manifests/kube-apiserver.yaml

...
spec:
  containers:
  - command:
    - kube-apiserver
    - --authorization-mode=Node,RBAC
    - --client-ca-file=/etc/kubernetes/pki/ca.crt #集群组件间通讯用的证书都由集群根CA签发，如controller-manager、scheduler、kube-proxy、kubelet等组件
```

证书中有两个身份凭证相关的重要字段：

- CN：apiserver在认证过程中将其作为用户（user）
- O：apiserver在认证过程中将其作为组（group）

![img](https://gitee.com/c_honghui/picture/raw/master/img/20220306140439.png)







kubeconfig（ .kube/config）：

kubeconfig文件包含集群参数（ca证书、apiserver地址）、客户端参数（生成的证书和私钥）、集群context信息（集群名称、用户名）。k8s通过启动时指定不同的kubeconfig文件可以切换不同的集群。

### Service Accout Tokens

上面讲的是k8s各种组件访问apiserver，那么pod中的容器访问api server，因为pod的创建、销毁都是动态的，所以无法为它手动颁发证书，k8s使用**serviceaccount解决pod访问api server的认证问题**

当创建一个namespace时，会同时在该namespace下生成名为default的sa和对用的secret

sa包含三个部分：**token、ca.crt、namespace**

```shell
#进入容器
kubectl exec  kube-proxy-cmzp6 -n=kube-system -it -- /bin/sh
cd /run/secrets/kubernates.io/serviceaccount/
ls #里面有ca.crt(根的证书)   namespace  token 3个文件

#token是使用 API Server 私钥签名的 JWT（json web token）。用于访问API Server时，Server端认证
#ca.crt，根证书(是k8s中私有的)。用于Client端验证API Server发送的证书
#namespace, 标识这个service-account-token的作用域名空间

service Account密钥对 sa.key sa.pub
提供给 kube-controller-manager使用，kube-controller-manager通过 sa.key 对 token 进行签名,
master 节点通过公钥 sa.pub 进行签名的验证 如 kube-proxy 是以 pod 形式运行的, 在 pod 中, 
直接使用 service account 与 kube-apiserver 进行认证, 此时就不需要再单独为 kube-proxy 创建证书了,
会直接使用token校验。
```



总结：

![image-20220304150854137](https://gitee.com/c_honghui/picture/raw/master/img/20220304150901.png)

## 鉴权

上面的认证过程只是确认了双方可以通信，而鉴权是确定请求方可以访问哪些资源。现在一般用的授权方式是RBAC。

优点：

- 整个RBAC由几个API对象（role、clusterrole、rolebinding、clusterrolebinding）完成，同其他API对象一样可以用kubectl或API进行操作
- 可以在运行时进行调整，不用重启API Server

### RBAC

从1.6版本起，Kubernetes 默认启用RBAC访问控制策略。

#### 角色

- Role、ClusterRole：是一组权限的集合，这里的权限都是许可形式的，**不存在拒绝的规则**，**Role只作用于命名空间内，ClusterRole作用于整个集群**


角色绑定：

- RoleBinding、ClusterRoleBinding：把角色绑定到目标上，绑定目标可以是**User、Group或者Service Account**，从而让这些目标拥有该角色的权限


##### Role

允许“被作用者”，对pod-reader这个namespace下的pod做"get", "watch", "list"操作：

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
    namespace: default
    name: pod-reader
rules: #定义权限
- apiGroups: [""]  # 空字符串表示核心API群
  resource: ["pods"] #资源类型："services", "endpoints", "pods","secrets","configmaps","crontabs","deployments","jobs","nodes","rolebindings","clusterroles","daemonsets","replicasets","statefulsets","horizontalpodautoscalers","replicationcontrollers","cronjobs"
  verbs: ["get", "watch", "list"] #对资源对象的操作："get", "list", "watch", "create", "update", "patch", "delete", "exec"
```

那么这个“被作用者”要如何指定？这就需要通过RoleBinding实现

##### ClusterRole

想要跨namespace可以用clusterrole

因其集群级别的范围，还可以用于以下**特殊元素**的授权：

- 集群范围的资源，例如Node
- 非资源型的路径，例如/healthz
- 包含全部命名空间的资源，例如pods

允许“被作用者”，对所有secrets做"get", "watch", "list"操作：

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-reader
  # ClusterRole不受限于命名空间，所以省略了namespace name的定义
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "watch", "list"]
```

##### 角色绑定(RoleBinding)和集群角色绑定(ClusterRoleBinding)

在default命名空间中把pod-reader角色授予用户jane，可以让jane用户读取default命名空间的Pod

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: default
subjects: #授权的目标，即“被作用者”
- kind: User
  name: jane
  apiGroup: rbac.authorization.k8s.io
roleRef: #引用之前定义好的Role，这样Role和“被作用者”就绑定在一起
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

允许manager组的用户读取任意namespace中的secret

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: read-secrets-global
subjects:
- kind: Group
  name: manager
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
```

**rolebinding同样可以引用clusterrole（但clusterrolebinding只能绑定clusterrole）**，可以定义一些通用的clusterrole，然后在不同的namespace下用rolebinding来引用

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: lol
subjects:
- kind: User
  name: jane
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

##### resources

k8s的一些资源一般以其名称字符串来表示，这些字符串一般在API的URL出现，同时这些资源也会包含子资源，例如logs资源就是pod的子资源，API的URL如下：

```shell
GET /api/v1/namespaces/{namespace}/pods/{name}/log
```

如果要在RBAC授权控制这些子资源的访问权限，可用斜线/来分割资源和下级资源，以下是授权让某个主体同时能够读取Pod和Pod log

```yaml
rules:
- apiGroups: [""]
  resources: ["pods", "pods/log"]
  verbs: ["get", "list"]
```

资源还可以通过名字(ResourceName)进行引用,资源还可以通过名字(ResourceName)进行引用

```yaml
rules:
- apiGroups: [""]
  resources: ["configmap"]
  resourceNames: ["my-configmap"]
  verbs: ["update", "get"]
```

#### 账号

前面rolebinding定义了“被作用者”subjects字段，它的类型是user，那么这个user是从哪来的？

其实k8s本身不提供用户管理能力，大多数时候不太使用用户这个功能，而是直接使用 Kubernetes 里的“内置用户”——ServiceAccount。

**ServiceAccount 分配权限的过程：**

创建sa、role、rolebinding

查看一下这个 ServiceAccount 的详细信息：

```shell

$ kubectl get sa -n mynamespace -o yaml
- apiVersion: v1
  kind: ServiceAccount
  metadata:
    creationTimestamp: 2018-09-08T12:59:17Z
    name: example-sa
    namespace: mynamespace
    resourceVersion: "409327"
    ...
  secrets:
  - name: example-sa-token-vmfg6
```

可以看到k8s会自动给sa创建一个secret，这个secret就是sa用来跟apiserver进行交互的授权文件，我们一般称为Token，

当pod引用这个sa，这个sa的secret就会自动挂载到容器的/var/run/secrets/kubernetes.io/serviceaccount 目录下

```shell

$ kubectl describe pod sa-token-test -n mynamespace
Name:               sa-token-test
Namespace:          mynamespace
...
Containers:
  nginx:
    ...
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from example-sa-token-vmfg6 (ro)
```

进入容器查看这个目录的文件

```shell

$ kubectl exec -it sa-token-test -n mynamespace -- /bin/bash
root@sa-token-test:/# ls /var/run/secrets/kubernetes.io/serviceaccount
ca.crt namespace  token
```

容器里的应用，就可以使用这个 ca.crt 来访问 APIServer 了

如果一个pod没有声明sa，k8s会在它的namespace下创建一个名为default的sa，然后分配给这个pod。

```shell
kubectl get sa
NAME      SECRETS   AGE
default   1         62d

kubectl get po nginx-7975c75659-f2fqd -oyaml|grep "serviceAccount"
  serviceAccount: default
  serviceAccountName: default
```

但在这种情况下，这个默认 ServiceAccount 并没有关联任何 Role。也就是说，此时它有访问 APIServer 的绝大多数权限。

所以，在生产环境中，我强烈建议你为所有 Namespace 下的默认 ServiceAccount，绑定一个只读权限的 Role。



Kubernetes 还拥有“用户组”（Group）的概念，实际上，一个 ServiceAccount，在 Kubernetes 里对应的“用户”的名字是：

```shell
system:serviceaccount:<Namespace名字>:<ServiceAccount名字>
```

而它对应的内置“用户组”的名字，就是：

```shell
system:serviceaccounts:<Namespace名字>
```

比如，role授权给mynamespace 里的所有 ServiceAccount，就用到了“用户组”概念

```yaml
subjects:
- kind: Group
  name: system:serviceaccounts:mynamespace
  apiGroup: rbac.authorization.k8s.io
```

role授权给整个系统 里的所有 ServiceAccount

```yaml
subjects:
- kind: Group
  name: system:serviceaccounts
  apiGroup: rbac.authorization.k8s.io
```

**在 Kubernetes 中已经内置了很多个为系统保留的 ClusterRole，它们的名字都以 system: 开头。你可以通过 kubectl get clusterroles 查看到它们。**

除此之外，Kubernetes 还提供了四个预先定义好的 ClusterRole 来供用户直接使用：cluster-admin；admin；edit；view。



**ServiceAccount 主要是用于解决Pod在集群中的身份认证问题，一般用于集群内部 Pod 进程使用，和 api-server 交互，而普通用户一般用于 kubectl 或者 REST 请求使用**



k8s并不会提供用户管理，那么user指定的用户从哪里来？k8s组件（kubectl、kube-proxy）或是其他自定义用户在向ca申请证书时，需要提供一个证书请求文件：

```yaml
{
  "CN": "admin",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Beijing",
      "L": "Beijing",
      "O": "system:masters",
      "OU": "Kubernetes-manual"
    }
  ]
}
```

api server会把客户端的证书的`CN`字段作为user，把`name.O`作为group

kubelet使用TLS Bootstaping认证时，k8s会为token绑定一个默认的user和group

pod使用sa认证时，service-account-token中的JWT会保存user信息

有了用户信息，就可以授权

#### 常用权限

允许读取核心API组中Pod的资源：

```yaml
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
```

允许读写"extensions"和"apps"两个API组中的deployment资源

```yaml
rules:
- apiGroups: ["extensions", "apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
```

允许读写pods及读写jobs

```yaml
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["batch", "extensions"]
  resources: ["jobs"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
```

允许读取一个名为my-config的ConfigMap(必须绑定到一个RoleBinding来限制到一个namespace下的ConfigMap)：

```yaml
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  resourceNames: ["my-config"]
  verbs: ["get"]
```

读取核心组的node资源(Node属于集群级别的资源，必须放在ClusterRole中，并使用ClusterRoleBinding进行绑定)：

```yaml
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "watch"]
```

允许对非资源端点/healthz及其所有子路径进行GET/POST操作(必须使用ClusterRole和ClusterRoleBinding)：

```yaml
rules:
- nonResourceURLs: ["/healthz", "/healthz/*"]
  verbs: ["get", "post"]
```

### 实践

#### Role --> User -->Rolebinding 

开发人员(用户chh)生成私钥和csr

```shell
cd /etc/kubernetes/pki/
openssl genrsa -out chh.key 2048
openssl req -new -key chh.key -out chh.csr -subj "/CN=chh"
```

集群管理员基于csr文件签发证书

```shell
openssl x509 -req -in chh.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -out chh.crt -days 365
kubectl config set-credentials chh --client-certificate=./chh.crt --client-key=./chh.key --embed-certs=true
kubectl config set-context chh@kubernetes --cluster=kubernetes --user=chh
```

定义Role

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: null
  name: pods-reader
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - watch
```

定义Rolebinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  creationTimestamp: null
  name: chh-read-pods
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: pods-reader
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: chh
```

查看rolebinding

```shell
kubectl describe rolebinding chh-read-pods
Name:         chh-read-pods
Labels:       <none>
Annotations:  <none>
Role:
  Kind:  Role
  Name:  pods-reader
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  chh   
```

切换到chh账号

```shell
kubectl config use-context chh@kubernetes
```

现在只能查看当前namespace的pod

```shell
kubectl get po -n kube-system
Error from server (Forbidden): pods is forbidden: User "chh" cannot list resource "pods" in API group "" in the namespace "kube-system"
```

#### ClusterRole-->ClusterRoleBinding-->User

 定义clusterrole

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-read
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - watch
```

定义clusterrolebinding

```yaml
kind: ClusterRoleBinding
metadata:
  creationTimestamp: null
  name: chh-read-all-pods
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-read
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: chh
```

切换到chh账号，现在可以查看所有namespace的pod

```shell
kubectl get po -A
```

#### 让chh用户访问指定namespace的资源

创建一个chh用户，可以发现无法访问api server

```shell
# su - chh
$ kubectl get po
The connection to the server localhost:8080 was refused - did you specify the right host or port?
```

下载证书生成工具

```shell
wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
mv cfssl_linux-amd64 /usr/local/bin/cfssl

wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
mv cfssljson_linux-amd64 /usr/local/bin/cfssljson

wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
mv cfssl-certinfo_linux-amd64 /usr/local/bin/cfssl-certinfo

chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson

cd /etc/kubernetes/pki
cfssl gencert -ca=ca.crt -ca-key=ca.key -profile=kubernetes /root/chh-csr.json | cfssljson -bare chh
```

设置集群参数

```shell
kubectl config set-cluster kubernetes \
     --certificate-authority=/etc/kubernetes/pki/ca.crt \
     --embed-certs=true \
     --server=https://192.168.101.200:16443 \ #apiserver地址可以看/etc/kubernetes/kubelet.conf
     --kubeconfig=chh.kubeconfig
```

设置客户端认证参数

```shell
kubectl config set-credentials chh \
     --client-certificate=/etc/kubernetes/pki/chh.pem \
     --client-key=/etc/kubernetes/pki/chh-key.pem \
     --embed-certs=true \
     --kubeconfig=chh.kubeconfig
```

设置上下文参数

```shell
kubectl config set-context kubernetes \
     --cluster=kubernetes \ #集群名称
     --user=chh \ #系统用户
     --namespace=ingress-nginx \ #用户可以访问的namespace
     --kubeconfig=chh.kubeconfig
```

把chh.kubeconfig拷贝到chh用户家目录的.kube目录

```shell
mkdir /home/chh/.kube
mv chh.kubeconfig /home/chh/.kube/configs
chown -R chh:chh /home/chh/.kube/config
```

创建rolebinding

```shell
kubectl create rolebinding chh-admin-binding --clusterrole=admin --user=chh --namespace=ingress-nginx
```

设置默认上下文

```shell
su - chh
cd ./kube
kubectl config use-context kubernetes --kubeconfig=config
```

现在chh用户可以访问ingress-nginx这个namespace的资源

```shell
[chh@k8s-master01 .kube]$ kubectl get po
NAME                             READY   STATUS    RESTARTS   AGE
ingress-nginx-controller-s4gjn   1/1     Running   0          143m
```

#### 只有访问权限去登录dashboard

有两种登陆认证方式可供选择：Kubeconfig 和 Token 方式（其实两种方式都需要服务账号的 Token）

在default空间创建一个sa

```shell
kubectl create sa kube-dashboard-reader
```

将系统自带的 ClusterRole：view 角色绑定到上一步创建的服务账号，授予集群范围的资源只读权限

```shell
kubectl create clusterrolebinding kube-dashboard-reader --clusterrole=view --serviceaccount=default:kube-dashboard-reader
```

获取服务账号的 token

```shell
kubectl describe secret kube-dashboard-reader
```

kubeconfig方式登录：

```yaml
在 Kubeconfig 的 Users 下 User 部分添加:
...
users:
- name: kubernetes-admin
  user:
    client-certificate-data: ...
    client-key-data: ...
    token: <这里为上面获取的 Token...>
```

token方式登录：

将获取的token填入

## 准入控制

经过认证（能不能跟我通信）、鉴权（是否有权这么做），最后是准入控制（能不能这么干）

准入控制就是在创建资源经过认证、授权之后，kube-apiserver在数据写入etcd之前做一次拦截，然后对资源进行更改、判断正确性等操作。