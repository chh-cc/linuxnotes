# Deployment

## 控制器

我们无法直接管理Pod，因为会遇到以下问题：

- 如何保证集群可用Pod数量？
- 如何更新所有Pod？
- 更新过程怎么保证服务可用，怎么回滚？



控制平面有一个kube-controller-manager 的组件，这个组件实际上就是一系列控制器的集合。

```shell
$ cd kubernetes/pkg/controller/
$ ls -d */             
deployment/             job/                    podautoscaler/         
cloud/                  disruption/             namespace/             
replicaset/             serviceaccount/         volume/
cronjob/                garbagecollector/       nodelifecycle/          replication/            statefulset/            daemon/
...
```

这个目录下面的每一个控制器，都以独有的方式负责某种编排功能。而我们的 Deployment，正是这些控制器中的一种。

## Deployment

用于**部署无状态的服务**，这个是最常用的控制器。一般用于管理维护企业内部无状态的微服务，比如configserver、zuul、springboot。应用场景：

- 创建一组pod
- 滚动升级和回滚应用
- 扩容和缩容
- 暂停和继续deployment

**它所管理的Pod的IP、名字，启停顺序等都是随机的**



deployment、RS和pod的关系：

**deployment控制管理RS，一个RS对应一个版本；RS根据replicaset来控制pod副本数**

![image-20220323234035126](https://gitee.com/c_honghui/picture/raw/master/img/20220323234035.png)



RS保证系统中pod的个数永远等于指定个数，这也正是deployment只允许容器的restartPolicy=Always的主要原因：只有pod一直保持在running的状态下，RS调整pod数才有意义。

而deployment操作RS来控制RS的个数和属性，进而实现“水平扩缩”和“滚动更新”这两个编排动作。



## 使用deployment创建pod

```yaml
cat nginx-deploy.yaml

apiVersion: apps/v1
kind: Deployment
metadata: #deployment元数据
  annotations: #自定义注释
    deployment.kubernetes.io/revision: "1"
  labels: #deploy标签
    app: nginx
  name: nginx #deploy名称
  namespace: default
spec:
  progressDeadlineSeconds: 600 #部署超时时间(s)
  replicas: 3 #副本数
  revisionHistoryLimit: 10 #设置保留rs旧的revision个数，0则无法滚动更新
#  minReadySeconds: 0 #可选参数，新创建的Pod状态为Ready持续的时间至少为几秒才认为可用，默认0即被创建就视为可用
  selector: #标签选择器，通过它指定该控制器管理哪些pod，必须匹配 .spec.template.metadata.labels
    matchLabels:
      app: nginx
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template: #pod模板
    metadata:
      labels:
        app: nginx #pod标签
    spec:
      containers:
      - image: nginx:1.15.2
        imagePullPolicy: IfNotPresent
        name: nginx
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      - image: ...
        name: nginx1 #一个pod里多个容器的容器名不能相同
        ...
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
```

创建pod

```shell
kubectl apply -f nginx-deploy.yaml --record
#加--record可以记录命令，可以方便查看每次revision的变化

kubectl get po
NAME                     READY   STATUS    RESTARTS   AGE
nginx-66bbc9fdc5-4mhfr   1/1     Running   0          5s
nginx-66bbc9fdc5-59zzq   1/1     Running   0          5s
nginx-66bbc9fdc5-zhkcc   1/1     Running   0          5s
```

重新加载deployment.yaml文件

```shell
kubectl replace -f nginx-deploy.yaml
```

查看deployment状态

```shell
kubectl get deploy -owide

NAME                               READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR
nginx   		  					3/3     3            3           41s   nginx        nginx:1.15.2   app=nginx
```

删除deployment

```shell
kubectl delete deploy nginx
```

## deployment更新

### 更新RS

查看一个deployment创建后的状态信息：

```shell
$ kubectl get deployments
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         0         0            0           1s

1. DESIRED：用户期望的 Pod 副本个数（spec.replicas 的值）；
2. CURRENT：当前处于 Running 状态的 Pod 的个数；
3. UP-TO-DATE：当前处于最新版本的 Pod 的个数，所谓最新版本指的是 Pod 的 Spec 部分与 Deployment 里 Pod 模板里定义的完全一致；
4. AVAILABLE：当前已经可用的 Pod 的个数，即：既是 Running 状态，又是最新版本，并且已经 处于 Ready（健康检查正确）状态的 Pod 的个数。
```

实时查看 Deployment 对象的状态变化：

```shell
$ kubectl rollout status deployment/nginx-deployment
Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
deployment.apps/nginx-deployment successfully rolled out

#意味着已经有 2 个 Pod 进 入了 UP-TO-DATE 状态。
```

继续等待一会儿，我们就能看到这个 Deployment 的 3 个 Pod，就进入到了 AVAILABLE 状态：

```shell
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         3         3            3           20s
```

只有修改了 Deployment Pod 模板`.spec.template`时，才会触发更新，生成新的RS

<img src="https://gitee.com/c_honghui/picture/raw/master/img/20220318215448.png" alt="image-20220318215447996" style="zoom:67%;" />

镜像更新触发Deployment:

```shell
kubectl set image deploy nginx nginx=nginx:1.17.1 --record
#容器名字=新的镜像名字
```

查看上线状态:

```shell
kubectl rollout status deploy nginx
```

查看 Deployment 创建的 ReplicaSet

```shell
kubectl get rs
NAME               DESIRED   CURRENT   READY   AGE
nginx-58b695f848   3         3         3       18m
nginx-66bbc9fdc5   0         0         0       82m
```

### 更新策略

两种更新策略：RollingUpdate（滚动更新，默认）和Recreate（重建，先删除pod再创建pod）

配置：

```yaml
.spec.strategy.type
	RollingUpdate #滚动更新
		maxUnavailable #滚动过程最多多少个pod不可用，可以是正整数或百分比，默认25%，向下取整，0.5算0
		maxSurge #滚动过程最多可以新建多少个Pod，可以是正整数或百分比，默认25%，向上取整，0.5算1
```

可以通过命令查看pod的动态变化：

```shell
kubectl get po -w
```



假设maxSurg(可超过期望值的副本数)=1, maxUnavailable(最多不可用副本数)=1, desired replicas(期望值副本数)=3，更新流程如下：

![image-20211128012054459](https://gitee.com/c_honghui/picture/raw/master/img/20211128012054.png)



更新的时候，新创建1个pod，这时达到pod数的上限值4个

不会等NewRS创建的Pods Ready，而是马上删掉1个旧的pod，再创建一个新的pod，这时Ready的Pods number最差也能保证desired replicas - maxUnavailable(2个)

接下来的流程是不固定，只要新建的Pods有几个返回Ready，则意味着可以接着删除几个旧的Pods了。只要有几个删除成功的Pods返回，就会创建一定数量的Pods，两个新创建的pod都可用后删除两个旧的pod，然后再创建一个新的pod

如此进行滚动更新， 直到创建的新Pods个数达到desired replicas，并等待它们都Ready，然后再删除所有剩余的旧的Pods。至此，滚动流程结束。

## deployment回滚

Deployment 的所有上线更新记录都保留在系统中，当deployment更新失败时，可以随时回滚

回滚过程其实是控制器重新调整下属RS的replica数量，最终使旧版的RS重新扩出所有的Pod

<img src="https://gitee.com/c_honghui/picture/raw/master/img/20220318221103.png" alt="image-20220318221103373" style="zoom:67%;" />



为了保存版本升级的历史，需要再创建Deployment对象时，在命令中使用"--record"选项

Deployment 修订历史：

```shell
kubectl rollout history deploy nginx
deployment.apps/nginx 
REVISION  CHANGE-CAUSE
1         <none>
2         kubectl set image deploy nginx nginx=nginx:1.17.1 --record=true
```

回滚到上一个版本：

```shell
kubectl rollout undo deploy nginx
```

查看指定版本的详细信息：

```shell
kubectl rollout history deploy nginx --revision=5
```

回滚到指定版本：

```shell
kubectl rollout undo deploy nginx --to-revision=5
```

## deployment扩容和缩容

Deployment Controller 只需要修改它所控制的 ReplicaSet 的 Pod 副本个数就可以了

比如2改成3，RS就会创建出一个新的pod

<img src="https://gitee.com/c_honghui/picture/raw/master/img/20220318214334.png" alt="image-20220318214327218" style="zoom:67%;" />

扩容为5个副本：

```shell
kubectl scale deploy --replicas=5 nginx
```

缩容为3个副本：

```shell
kubectl scale deploy --replicas=3 nginx
```

## deployment更新暂停和恢复

暂停更新：

```shell
kubectl rollout pause deployment nginx
```

第一次变更配置：

```shell
kubectl set image deploy nginx nginx=nginx:1.15.3 --record
```

第二次变更配置：

```shell
kubectl set resources deploy nginx -c nginx --limits=cpu=200m,memory=128Mi --requests=cpu=10m,memory=16Mi
```

恢复更新：

```shell
kubectl rollout resume deploy nginx
```

