## 全局配置文件

```yaml
vim prometheus.yml
global:
	scrape_interval:     15s	#采集目标主机监控据的时间间隔，默认1m
	evaluation_interval: 15s	#触发告警检测的时间间隔（频率），默认1m
	scrape_timeout: 15s	#采集数据的超时时间，该值不能大于scrape_interval的值，默认10s。

#记录规则和告警规则（比如cpu超过多少发送告警）
rule_files:
    ...
    
#配置被监控端，称为target，每个target用job_name命名，又分静态配置和服务发现
scrape_configs:
    ...
    
#告警配置
alerting:
  alert_relabel_configs: # - 警报重新标记在发送到Alertmanager之前应用于警报,用途是确保一对具有不同外部标签的Prometheus服务器发送相同的警报。
  alertmanagers:
    [ timeout: <duration> | default = 10s ]     # Per-target Alertmanager timeout when pushing alerts.
    [ api_version: <string> | default = v2 ]    # The api version of Alertmanager.
    [ path_prefix: <path> | default = / ]       # Prefix for the HTTP path alerts are pushed to.
    [ scheme: <scheme> | default = http ]       # Configures the protocol scheme used for requests. 作者：WeiyiGeek 
```

## scrape_configs

```yaml
#采集对象的作业名称
- job_name: <job_name>

  #默认继承全局配置global，在这指定局部配置会覆盖全局配置
  [ scrape_interval: 15s ]
  [ scrape_timeout: 15s ]

  #指标路径
  [ metrics_path: /metrics ]
  #标签
  [ honor_labels: <boolean> | default = false ]

  #目标拉取协议
  [ scheme: <scheme> | default = http ]

  #参数
  params:
    [ <string>: [<string>, ...] ]

  #基础认证
  basic_auth:
    [ username: <string> ]
    [ password: <secret> ]
    [ password_file: <string> ]
  tls_config:
    [ <tls_config> ]
      [ ca_file: <filename> ]     # 用于验证API服务器证书的CA证书。
      [ cert_file: <filename> ]   # 用于向服务器进行客户端证书身份验证的证书和密钥文件。
      [ key_file: <filename> ]
      [ server_name: <string> ]   # 用于指示服务器的名称(https://tools.ietf.org/html/rfc4366#section-3.1)
      [ insecure_skip_verify: <boolean> ] # 禁用服务器证书验证。
  [ proxy_url: <string> ]

  #设置多种服务发现，最常见有以下两种方式
  ## 基于文件的服务发现提供了一种更通用的方法来配置静态目标，并充当插入自定义服务发现机制的接口(文件可以YAML或JSON格式提供,格式样例看下面的tips)
  file_sd_configs:
    - files:
      - my/path/tg_*.json
      [ refresh_interval: <duration> | default = 5m ] # 该静态文件刷新时间间隔
  # 基于kubernetes的服务发现,允许从 Kubernetes REST API 拉取集群pod相关信息并时刻保持同步。
  kubernetes_sd_configs:
    [ - <kubernetes_sd_config> ... ]
  ...

  #指定静态目标
  static_configs:
  - target: ['localhost:9090','localhost:9191']
    labels:
      [ <labelname>: <labelvalue> ... ]
        
  #重新标记  
  relabel_configs:
    ...
  
  metric_relabel_configs:
  ...
  
  [ sample_limit: <int> | default = 0 ] ## 每次刮取将被接受的刮取样品数量限制(0 means no limit)。
```

## relabel_configs

### 标签的作用

Prometheus中存储的数据为时间序列，是由Metric的名字和一系列的标签(键值对)唯一标识的, **不同的标签代表不同的时间序列**，即**通过指定标签查询指定数据** 

指标+标签实现了查询条件的作用，可以指定不同的标签过滤不同的数据

### Metadata标签

在Prometheus所有的Target实例中，都包含一些默认的Metadata标签信息。可以通过Prometheus UI的Targets页面中查看这些实例的Metadata标签的内容：

![image-20220707224547619](assets/image-20220707224547619.png)

- **\__address__：当前Target实例的访问地址<host>:<port>**

- **\__scheme__：采集目标服务访问地址的HTTP Scheme，HTTP或者HTTPS**

- **\__metrics_path__：采集目标服务访问地址的访问路径**

上面这些标签将会告诉Prometheus如何从该Target实例中获取监控数据。

**使用promql是查询不到这些标签的，因为这些标签只是普罗米修斯内部去使用的，不会存储在时序数据库供我们查询**

### k8s服务发现

 k8s服务发现从以下的role方式进行目标发现

- node : 为每个群集节点发现一个目标，其地址默认为Kubelet的HTTP端口，地址类型顺序: NodeInternalIP, NodeExternalIP, NodeLegacyHostIP, and NodeHostName. 

  ```shell
  # Available meta labels: 此外instance节点的标签将设置为从API服务器检索到的节点名。
  __meta_kubernetes_node_name：节点对象的名称
  __meta_kubernetes_node_label_<labelname>：节点对象中的每个标签。
  __meta_kubernetes_node_labelpresent_<labelname> :是的对于节点对象中的每个标签。
  __meta_kubernetes_node_annotation_<annotationname>：来自节点对象的每个注释。
  __meta_kubernetes_node_annotationpresent_<annotationname> :是的对于节点对象中的每个注释。
  __meta_kubernetes_node_address_<address_type>：每个节点地址类型的第一个地址（如果存在）。 
  ```

- service : 为每个服务的每个服务端口发现一个目标。这对于服务的黑盒监视通常很有用。地址将设置为服务的Kubernetes DNS名称和相应的服务端口。 

  ```shell
  __meta_kubernetes_namespace：服务对象的命名空间。
  __meta_kubernetes_service_annotation_<annotationname>：来自服务对象的每个批注。
  __meta_kubernetes_service_annotationpresent_<annotationname>：“true”表示服务对象的每个注释。
  __meta_kubernetes_service_cluster_ip：服务的群集IP地址(不适用于ExternalName类型的服务）
  __meta_kubernetes_service_external_name：服务的DNS名称(适用于ExternalName类型的服务）
  __meta_kubernetes_service_label_<labelname>：来自服务对象的每个标签。
  __meta_kubernetes_service_labelpresent_<labelname> :是的对于服务对象的每个标签。
  __meta_kubernetes_service_name：服务对象的名称
  __meta_kubernetes_service_port_name：目标的服务端口的名称。
  __meta_kubernetes_service_port_protocol：目标的服务端口的协议。
  __meta_kubernetes_service_type：服务的类型 
  ```

- pod : 发现所有pod并将其容器作为目标公开。对于容器的每个声明端口，生成一个单独的目标。如果容器没有指定的端口，则为每个容器创建一个端口空闲目标，以便通过重新标记手动添加端口。 

  ```shell
  __meta_kubernetes_namespace：pod对象的命名空间。
  __meta_kubernetes_pod_name：pod对象的名称
  __meta_kubernetes_pod_ip：pod对象的pod IP。
  __meta_kubernetes_pod_label_<labelname>：pod对象中的每个标签。
  __meta_kubernetes_pod_labelpresent_<labelname> :是的对于pod对象中的每个标签。
  __meta_kubernetes_pod_annotation_<annotationname>：pod对象中的每个注释。
  __meta_kubernetes_pod_annotationpresent_<annotationname> :是的对于pod对象的每个注释。
  __meta_kubernetes_pod_container_init :是的如果容器是 初始化容器
  __meta_kubernetes_pod_container_name：目标地址指向的容器的名称。
  __meta_kubernetes_pod_container_port_name：容器端口的名称
  __meta_kubernetes_pod_container_port_number：集装箱端口号
  __meta_kubernetes_pod_container_port_protocol：集装箱港口的协议
  __meta_kubernetes_pod_ready：设置为是的或false吊舱准备就绪
  __meta_kubernetes_pod_phase：设置为悬而未决的 ,Running ,成功 ,Failed或未知在生命周期 .
  __meta_kubernetes_pod_node_name：pod被调度到的节点的名称。
  __meta_kubernetes_pod_host_ip：pod对象的当前主机IP。
  __meta_kubernetes_pod_uid：pod对象的UID。
  __meta_kubernetes_pod_controller_kind：pod控制器的对象类型。
  __meta_kubernetes_pod_controller_name：吊舱控制器的名称 
  ```

- endpoints : 从服务的列出的终结点发现目标。对于每个endpointaddress，每个端口都会发现一个目标。如果端点由一个pod支持，那么pod的所有附加容器端口（未绑定到端点端口）也会被发现作为目标。 

  ```shell
  _meta_kubernetes_namespace：endpoints对象的命名空间。
  __meta_kubernetes_endpoints_name：endpoints对象的名称。
  对于直接从端点列表中发现的所有目标（未从底层POD中额外推断出的目标），将附加以下标签：
  __meta_kubernetes_endpoint_hostname：终结点的主机名
  __meta_kubernetes_endpoint_node_name：承载终结点的节点的名称。
  __meta_kubernetes_endpoint_ready：设置为是的或false对于端点的就绪状态
  __meta_kubernetes_endpoint_port_name：终结点端口的名称
  __meta_kubernetes_endpoint_port_protocol：终结点端口的协议
  __meta_kubernetes_endpoint_address_target_kind：终结点地址目标的类型。
  __meta_kubernetes_endpoint_address_target_name：终结点地址目标的名称。
  如果端点属于服务，则role: service发现已附加
  对于由吊舱支持的所有目标role: pod发现已附加 
  ```

- ingress : 为每个入口的每个路径发现一个目标。这通常对黑盒监控入口很有用地址将设置为入口规范中指定的主机。 

  ```shell
  __meta_kubernetes_namespace：ingress对象的命名空间。
  __meta_kubernetes_ingress_name -入口对象的名称
  __meta_kubernetes_ingress_label_<labelname>：来自ingress对象的每个标签。
  __meta_kubernetes_ingress_labelpresent_<labelname> :是的对于ingress对象中的每个标签。
  __meta_kubernetes_ingress_annotation_<annotationname>：来自ingress对象的每个注释。
  __meta_kubernetes_ingress_annotationpresent_<annotationname> :是的对于ingress对象的每个注释。
  __meta_kubernetes_ingress_scheme：入口协议方案，https如果设置了TLSconfig。默认为http .
  __meta_kubernetes_ingress_path：从入口规范的路径默认为 / . 
  ```

  

给样本增加一个自定义标签

```yaml
- job_name: 'prometheus'
  static_configs:
  - target: ['localhost:9090']
    labels:
      idc: bj  
```

### 重新标记标签

允许在采集之前对任何目标及其标签进行修改，**重新标记目的：为了更好的标识监控指标。**

重新标签的意义：

- 根据已有的标签生成新标签
- 删除标签
- 过滤采集的Target
- 添加新标签



relabel规则组成：

```yaml
relabel_configs:
  #源标签，对哪些源标签进行relabel
  [ source_labels: '[' <labelname> [, ...] ']' ]
  #分隔符，用于在连接源标签source_labels时分割它们
  [ separator: <string> | default = ; ]
  #目标标签，relabel后的标签名
  [ target_label: <labelname> ]
  #正则表达式，用于匹配串联的源标签
  [ regex: <regex> | default = (.*) ]
  #如果正则表达式匹配，则对其执行正则表达式替换的替换值
  [ replacement: <string> | default = $1 ]
  #执行的 relabeling 动作，可选值包括 replace、keep、drop、hashmod、labelmap、labeldrop 或者 labelkeep，默认值为 replace
  [ action: <relabel_action> | default = replace ]
```

relabel的action动作：

- replace：默认，通过regex匹配source_label的值，使用replacement来引用表达式匹配的分组，分组使用$1,$2...引用（正则匹配，提取字段重新创建新标签，注意这里是创建新的标签）
- keep：删除regex与连接不匹配的目标 source_labels ， **keep drop就是让普罗米修斯采集和不采集哪些目标**
- drop：删除regex与连接匹配的目标 source_labels
- labeldrop：删除regex匹配的标签
- labelkeep：删除regex不匹配的标签
- labelmap：匹配regex所有标签名称，并将捕获的内容分组，用第一个分组内容作为新的标签名（使用正则提取出多个字段，使用匹配到的作为新标签名，但是标签的内容不会改变，相对于对原有标签换了个名字）



例子：

```yaml
#把地址http://node-ip:10250/metrics替换成http://node-ip:9100/metrics
    - job_name: 'kubernetes-node'
      kubernetes_sd_configs: ##使用的是k8s的服务发现
      - role: node
      relabel_configs:
      - action: replace
        source_labels: [__address__] #要替换的源标签，匹配地址
        regex: '(.*):10250' #匹配带有10250端口的url
        replacement: '${1}:9100' #把匹配到的ip:10250的ip保留，端口替换成9100
        target_label: __address__ #新生成的标签名
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+) #匹配到下面正则表达式的标签会被保留,如果不做regex正则的话，默认只是会显示instance标签
```

![image-20230227180034869](assets/image-20230227180034869.png)



保留或丢弃对象：

Relabeling 另一个常见的用例就是过滤有标签的对象，keep 或 drop 这两个动作可以来完成，使用这两个操作，可以帮助我们完成如下的一些操作：

- 来自服务发现的哪些目标应该被抓取
- 从目标中抓取哪些指定的序列样本，或将其发送到远程存储
- 哪些报警要发送到 Alertmanager

```yaml
- job_name: 'kubernetes-service-endpoints'
  kubernetes_sd_configs:
  - role: endpoint
  relabel_configs:
  - action: keep
    source_labels: [__meta_kubernetes_service_annotation_example_io_should_be_scraped]
    regex: true

Kubernetes 服务发现机制下面会将 labels 标签与 annotation 作为元信息输出到 Prometheus，这些元信息都包含 __meta_ 前缀，这里我们的配置就是保留具有 example.io/should_be_scraped 这个 annotation 标签，且值为 true 的目标。
```

