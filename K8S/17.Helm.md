# Helm

## Helm安装

Helm安装文档

[Helm | Installing Helm](https://helm.sh/docs/intro/install/)

Helm安装包

[Releases · helm/helm (github.com)](https://github.com/helm/helm/releases)

## 为什么用helm

k8s能够很好地组织和编排容器，但它缺少一个更高层次的应用打包工具

比如对于一个MySQL服务，k8s需要部署这些对象：

- service，让集群能够访问mysql
- secret，定义mysql密码
- PVC，为mysql申请持久化存储空间
- deployment，部署mysql pod，并使用上面这些支持的对象

然后用`kubectl apply -f`命令部署即可

如果一个应用只由一个或几个服务组成，上面的部署完全够用；但是如果是微服务应用，组成的应用服务可能多达几十上百个，这种部署方式就很麻烦：

- 部署人员需要首先理解应用都包含哪些服务，然后按照逻辑顺序依次执行 `kubectl apply`

- 不能高效地共享和重用服务。比如两个应用都要用到 MySQL 服务，但配置的参数不一样，这两个应用只能分别拷贝一套标准的 MySQL 配置文件
- 不支持应用级别的版本管理。虽然可以通过 `kubectl rollout undo` 进行回滚，但这只能针对单个 Deployment，不支持整个应用的回滚。

## 概念

Helm是Kubernetes的包管理器，类似于centos的yum，主要用来管理 Charts

- Chart：是创建一个应用的信息集合，包括各种 Kubernetes 对象的配置模板、参数定义、依赖关系、文档说明等，类似yum的rpm文件
- Release：在Kubernetes集群上运行的Chart的一个实例。在同一个集群上，一个Chart可以安装很多次。每次安装都会创建一个新的release。

组件

- Helm CLI是Helm客户端，可以在Kubernetes集群的master节点或者本地执行。
- Tiller是服务器端组件，在Kubernetes集群上运行，并管理Kubernetes应用程序的生命周期。
- Repository是Chart存储库，Helm客户端通过HTTP协议来访问存储库中Chart的索引文件和压缩包。

Helm v3是直接与k8s api互通 无需再helm init 创建服务端，Helm2是CS结构，客户端称为Helm，服务端称为Tiller；Helm3只有客户端，称为Helm。

## 使用

```shell
#先添加常用的chart源
helm repo add stable https://kubernetes-charts.storage.googleapis.com
helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com  
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo add aliyuncs https://apphub.aliyuncs.com

#查看chart列表
[root@master nginx]# helm repo list
NAME        URL                                                       
stable      https://kubernetes-charts.storage.googleapis.com          
incubator   https://kubernetes-charts-incubator.storage.googleapis.com
bitnami     https://charts.bitnami.com/bitnami                        
aliyuncs    https://apphub.aliyuncs.com 
```

查看版本

```shell
[root@master nginx]# helm search repo nginx
NAME                                CHART VERSION   APP VERSION             DESCRIPTION                                       
aliyuncs/nginx                      5.1.5           1.16.1                  Chart for the nginx server                        
aliyuncs/nginx-ingress              1.30.3          0.28.0                  An nginx Ingress controller that uses ConfigMap...
aliyuncs/nginx-ingress-controller   5.3.4           0.29.0                  Chart for the nginx Ingress controller            
aliyuncs/nginx-lego                 0.3.1                                   Chart for nginx-ingress-controller and kube-lego  
aliyuncs/nginx-php                  1.0.0           nginx-1.10.3_php-7.0    Chart for the nginx php server                    
bitnami/nginx                       6.2.1           1.19.2                  Chart for the nginx server                        
bitnami/nginx-ingress-controller    5.5.1           0.35.0                  Chart for the nginx Ingress controller            
stable/nginx-ingress                1.41.3          v0.34.1                 DEPRECATED! An nginx Ingress controller that us...
stable/nginx-ldapauth-proxy         0.1.4           1.13.5                  nginx proxy with ldapauth                         
stable/nginx-lego                   0.3.1                                   Chart for nginx-ingress-controller and kube-lego  
bitnami/kong                        1.3.2           2.1.3                   Kong is a scalable, open source API layer (aka ...
stable/gcloud-endpoints             0.1.2           1                       DEPRECATED Develop, deploy, protect and monitor...
```

下载chart包

```shell
helm pull aliyuncs/nginx --untar #将nginx包从创库拉到当前目录
#查看结构
[root@master charts]# tree nginx/
nginx/
├── Chart.yaml #包含Chart的基本信息，包括chart版本，名称等
├── charts #依赖其他包的charts文件
├── README.md
├── templates #存放应用一系列 k8s 资源的 yaml 模板
│   ├── deployment.yaml
│   ├── _helpers.tpl #下划线开头，定义一些可重用的模板片断，可以被其他模板引用
│   ├── ingress.yaml
│   ├── NOTES.txt
│   ├── server-block-configmap.yaml
│   ├── servicemonitor.yaml
│   ├── svc.yaml
│   └── tls-secrets.yaml
└── values.yaml #包含了必要的值定义（默认值）, 用于存储 templates 目录中模板文件中用到变量的值

2 directories, 13 files
```

## Helm语法

### 模板引用

{{ .Release.Name }}, 通过双括号注入,小数点开头表示从最顶层命名空间引用

{{- 模版表达式 -}} ， 表示去掉表达式输出结果前面和后面的空格，去掉前面空格可以这么写{{- 模版表达式 }}, 去掉后面空格 {{ 模版表达式 -}}

### 内置对象

```yaml
# Release, release相关属性
# Chart, Chart.yaml文件中定义的内容
# Values, values.yaml文件中定义的内容
```

### 变量和变量作用域

默认情况最左面的点( . ), 代表全局作用域，用于引用全局对象，中间的点，很像是js中对json对象中属性的引用方式。

**Values**代表的就是values.yaml定义的参数：

```yaml
cat templates/deployment.yaml
#引用全局作用域下values对象的replicaCount属性
{{ .Values.replicaCount }}
#引用嵌套对象
{{ .Values.image.repository }}
```

### 管道

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
   name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | repeat 5 | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
```

### 流程控制语句

**with**主要就是用来修改 . 作用域的

```yaml
{{ .Values.a.b.c.repository }}
{{ .Values.a.b.c.pullPolicy }}
转成：
{{- with .Values.a.b.c }}
{{ .repository }}
{{ .pullPolicy }}
{{- end }}
```

如果还是想在with调用范围外的，可以在范围之外把想用的顶级内置函数定义为变量**{{- $name := .xxx.xxx }}**,在后面引用变量即可

```yaml
cat configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  {{- $name := .Release.Name }}
  {{- with .Values.data  }}
  drink: {{ .drink }}
  release: {{ $name }}
  # 或者可以使用$符号,引入全局命名空间
  release: {{ $.Release.Name }}
  {{- end }}
```

**if**语法

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- if eq .Values.favorite.drink "coffee"}}
  mug: true
  {{- end}}
  
#操作符, and/eq/or/not
```

**range**主要用于循环遍历数组类型

语法1:

 ```yaml
 #遍历map类型，用于遍历键值对象
 
 #变量$key代表对象的属性名，$val代表属性值
 
 {{- range $key, $val := 键值对象 }}
 {{ $key }}: {{ $val | quote }}
 {{- end}}
 ```

语法2：

```
{{- range 数组 }}
{{ . | title | quote }} # . (点)，引用数组元素值。
{{- end }}
```

```yaml
#values.yaml定义

#map类型
favorite:
  drink: coffee
  food: pizza

#数组类型
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

map类型遍历例子:
{{- range $key, $val := .Values.favorite }}
{{ $key }}: {{ $val | quote }}
{{- end}}

数组类型遍历例子:
{{- range .Values.pizzaToppings}}
{{ . | quote }} 
{{- end}}
```

### 子模版定义

可以在_(下划线)开头的文件中定义子模版，方便后续复用

helm create默认为我们创建了_helpers.tpl 公共库定义文件，可以直接在里面定义子模版，也可以新建一个，只要以下划线开头命名即可

语法：

```yaml
定义模版:
{{ define "模版名字" }} 模版内容 {{ end }}

引用模版:
{{ include "模版名字" 作用域}}
```

### 函数

http://masterminds.github.io/sprig/strings.html