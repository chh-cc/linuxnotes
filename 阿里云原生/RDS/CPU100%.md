cpu超过100%，实例偶尔出现卡住的现象



通过show processlist发现如下sql：

Sql A.

```sql
| 2815961 | sanwenba  | 10.241.142.197:55190 | sanwenba | Query   | 0 | Sorting RESULT       | 
SELECT z.aid,z.subject FROM www_zuowen z RIGHT JOIN www_zuowenaddviews za ON za.aid=z.aid 
ORDER BY za.viewnum DESC LIMIT 10;
```

用explain 查看执行计划：

```sql
sanwenba@3018 10:00:54&gt;explain SELECT z.aid,z.subject FROM www_zuowen z 
RIGHT JOIN www_zuowenaddviews za ON za.aid=z.aid ORDER BY za.viewnum DESC LIMIT 10;
 
+----+-------------+-------+--------+---------------+---------+---------+-----------------+------
 
| id | select_type | TABLE | TYPE   | possible_keys | KEY     | key_len | REF     | ROWS   | Extra |
 
+----+-------------+-------+--------+---------------+---------+---------+-----------------+------
 
|  1 | SIMPLE      | za    | INDEX  | NULL          | viewnum | 6       | NULL            | 537029 | USING INDEX; USING filesort |
 
|  1 | SIMPLE      | z     | eq_ref | PRIMARY       | PRIMARY | 3       | sanwenba.za.aid |      1 |  |
```

添加适当索引消除排序：

```sql
sanwenba@3018 10:02:33 ALTER TABLE www_zuowenaddviews ADD INDEX ind_www_zuowenaddviews_viewnum(viewnum);
sanwenba@3018 10:03:27explain SELECT z.aid,z.subject FROM www_zuowen z RIGHT JOIN www_zuowenaddviews za ON za.aid=z.aid ORDER BY za.viewnum DESC LIMIT 10;
+----+-------------+-------+--------+---------------+--------------------------------+---------+-
 
| id | select_type | TABLE | TYPE   | possible_keys | KEY  | key_len | REF      | ROWS | Extra       |
 
+----+-------------+-------+--------+---------------+--------------------------------+---------+-
 
|  1 | SIMPLE      | za    | INDEX  | NULL  | ind_www_zuowenaddviews_viewnum | 3       | NULL       |   10 | USING INDEX |
 
|  1 | SIMPLE    | z     | eq_ref | PRIMARY PRIMARY | 3  | sanwenba.za.aid |    1 |             |
 
+----+-------------+-------+--------+---------------+--------------------------------+---------+-
```

Sql B:

```
| 2825321 | netzuowen | 10.200.120.41:44172  | netzuowen | Query |     2 | Copying TO tmp TABLE ON disk 
SELECT * FROM `www_article` WHERE 1=1 ORDER BY rand() LIMIT 0,30
```

这种sql order by rand()同样也会出现排序;

```
netzuowen@3018 10:23:55
EXPLAIN  SELECT * FROM `www_zuowensearch` WHERE checked = 1 ORDER BY rand() LIMIT 0,10 ;
+----+-------------+------------------+------+---------------+--------+---------+-------+------+
 
| id | select_type | TABLE            | TYPE | possible_keys | KEY    | key_len | REF   | ROWS | Extra|
 
+----+-------------+------------------+------+---------------+--------+---------+-------+------+
 
|  1 | SIMPLE      | www_zuowensearch | REF  | newest        | newest | 1       | const | 1443 | USING TEMPORARY; USING filesort |
 
+----+-------------+------------------+------+---------------+--------+---------+-------+------+
```

这种随机抽取一批记录的做法性能是很差的，表中的数据量越大，性能就越差：

解决方法如下：

http://www.piaoyi.org/php/MySQL-Order-By-Rand.html

第一种方案，即原始的 Order By Rand() 方法：

$sql=”SELECT * FROM content ORDER BY rand() LIMIT 12″;

$result=mysql_query($sql,$conn);

$n=1;

$rnds=”;

while($row=mysql_fetch_array($result)){

$rnds=$rnds.$n.”. <a href=’show”.$row[‘id’].”-“.strtolower(trim($row[‘title’])).”‘>”.$row[‘title’].”</a><br />\n”;

$n++;

}

3万条数据查12条随机记录，需要0.125秒，随着数据量的增大，效率越来越低。

第二种方案，改进后的 JOIN 方法：

for($n=1;$n<=12;$n++){

$sql=”SELECT * FROM `content` AS t1

JOIN (SELECT ROUND(RAND() * (SELECT MAX(id) FROM `content`)) AS id) AS t2

WHERE t1.id >= t2.id ORDER BY t1.id ASC LIMIT 1″;

$result=mysql_query($sql,$conn);

$yi=mysql_fetch_array($result);

$rnds = $rnds.$n.”. <a href=’show”.$yi[‘id’].”-“.strtolower(trim($yi[‘title’])).”‘>”.$yi[‘title’].”</a><br />\n”;

}

3万条数据查12条随机记录，需要0.004秒，效率大幅提升，比第一种方案提升了约30倍。缺点：多次select查询，IO开销大。

第三种方案，SQL语句先随机好ID序列，用 IN 查询（飘易推荐这个用法，IO开销小，速度最快）：

$sql=”SELECT MAX(id),MIN(id) FROM content”;

$result=mysql_query($sql,$conn);

$yi=mysql_fetch_array($result);

$idmax=$yi[0];

$idmin=$yi[1];

$idlist=”;

for($i=1;$i<=20;$i++){

if($i==1){ $idlist=mt_rand($idmin,$idmax); }

else{ $idlist=$idlist.’,’.mt_rand($idmin,$idmax); }

}

$idlist2=”id,”.$idlist;

$sql=”select * from content where id in ($idlist) order by field($idlist2) LIMIT 0,12″;

$result=mysql_query($sql,$conn);

$n=1;

$rnds=”;

while($row=mysql_fetch_array($result)){

$rnds=$rnds.$n.”. <a href=’show”.$row[‘id’].”-“.strtolower(trim($row[‘title’])).”‘>”.$row[‘title’].”</a><br />\n”;

$n++;

}

3万条数据查12条随机记录，需要0.001秒，效率比第二种方法又提升了4倍左右，比第一种方法提升120倍。注，这里使用了 order by field($idlist2) 是为了不排序，否则 IN 是自动会排序的。缺点：有可能遇到ID被删除的情况，所以需要多选几个ID。

C．出现sending data的情况：

```
| 2833185 | sanwenba        | 10.241.91.81:45964   | sanwenba | Query    |     1 | Sending DATA   |
 SELECT * FROM `www_article` WHERE CONCAT(subject,description) LIKE '%??%' ORDER BY aid DESC LIMIT 75,15
```

性能sql：

SELECT * FROM `www_article` WHERE CONCAT(subject,description) like ‘%??%’ ORDER BY aid desc LIMIT 75,15

这种sql是典型的sql分页写法不规范的情况，需要将sql进行改写：

```
SELECT * FROM www_article t1,(SELECT aid FROM www_article WHERE CONCAT(subject,description) LIKE '%??%' ORDER BY aid DESC LIMIT 75,15) t2 WHERE t1.aid=t2.aid;
```

注意这里的索引需要改用覆盖索引：aid+ subject+description