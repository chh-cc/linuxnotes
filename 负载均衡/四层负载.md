# 四层负载

## 负载均衡集群

使每个节点都可以承担一定的处理负载，并且可以实现处理负载在节点之间的动态分配，以实现负载均衡。

负载通常包括应用程序处理负载和网络流量负载。

**负载均衡技术类型：基于 4 层负载均衡技术和基于 7 层负载均衡技术**

**负载均衡实现方式：硬件负载均衡设备或者软件负载均衡**

**硬件负载均衡产品：F5 BIG-IP 、Citrix Netscaler  、深信服 、Array 、Radware**

**软件负载均衡产品： LVS（Linux Virtual Server）、 Haproxy、Nginx、Ats（apache traffic server）**

### 四层负载均衡

四层只能获取访问的目标IP和端口，应用场景包括对MySQL、Redis等四层应用做负载

## LVS 实现四层负载均衡

### 1、LVS 介绍

现在LVS已经是 Linux标准内核的一部分，

##### 1.优势

工作在网络二层/三层/四层之上仅作分发作用，对CPU和内存消耗极低

DR模式下流量会走后端服务器的网卡，性能强

配置性低，不需要太多接触

应用广，几乎可以对所有应用做负载均衡

##### 2.不足

ECS不支持

不支持七层的虚拟主机、rewrite、动静分离等功能，而许多web网站在这方面有较强需求

##### 3.核心组件

LVS的管理工具和内核模块 ipvsadm/ipvs

ipvsadm：用户空间的命令行工具，用于管理集群服务及集群服务上的RS等；

ipvs：工作于内核上的netfilter INPUT钩子之上的程序，可根据用户定义的集群实现请求转发；

##### 4.专业术语

**VS**：Virtual Server            #虚拟服务

**Director, Balancer**          #负载均衡器、分发器

**RS**：Real Server                #后端请求处理服务器 

**CIP**: Client IP                      #用户端IP

**VIP**：Director Virtual IP   #负载均衡器虚拟IP

**DIP**：Director IP               #负载均衡器IP

**RIP**：Real Server IP         #后端请求处理服务器

### 2、LVS工作内核模型及工作模式

1、当客户端的请求到达负载均衡器的内核空间时，首先会到达 PREROUTING 链。

2、当内核发现请求数据包的目的地址是本机时，将数据包送往 INPUT 链。

3、LVS由用户空间的ipvsadm和内核空间的IPVS组成，**ipvsadm用来定义规则**，**IPVS利用ipvsadm定义的规则工作**，IPVS工作在INPUT链上,当数据包到达INPUT链时，首先会被IPVS检查，如果数据包里面的目的地址及端口没有在规则里面，那么这条数据包将被放行至用户空间。

4、**如果数据包里面的目的地址及端口在规则里面，那么这条数据报文将被修改目的地址为事先定义好的后端服务器，并送往POSTROUTING链**。

5、最后经由POSTROUTING链发往后端服务器。

![](https://gitee.com/c_honghui/picture/raw/master/img/20210223110632.png)

### 3、LVS负载均衡四种工作模式

#### 1、NAT工作模式（四层）

工作流程：

1、 报文的源IP为CIP，目标IP为VIP

2、 负载均衡将报文目标地址改为RIP，并发送给后端

3、目标服务器会响应请求并返回给负载均衡，后端的网关地址必须是负载均衡所在服务器的内网地址，即要配置SNAT，这样数据包才能经过LVS返回给客户端

４、负载均衡将数据包的源地址修改为本机并发送给客户端



#### 2、DR 工作模式（二层）

工作流程：

1、 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP

2、 PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链

3、 IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的**源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址**，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址

4、 由于**DS和RS在同一个网络中，所以是通过二层，数据链路层来传输**。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server。

5、 RS发现请求报文的MAC地址是自己的MAC地址，就接收此报文。处理完成之后，将响应报文通过lo接口传送给eth0网卡然后向外发出。 此时的**源IP地址为VIP，目标IP为CIP**

6、 响应报文最终送达至客户端 



#### 3、LVS TUN 工作模式（三层）

工作流程：

1、 客户端将请求发往前端的负载均衡器，请求报文源地址是CIP，目标地址为VIP。

2、 负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将在客户端请求报文的首部再封装一层IP报文,将源地址改为DIP，目标地址改为RIP,并将此包发送给RS。

3、 RS收到请求报文后，会首先拆开第一层封装,然后发现里面还有一层IP首部的目标地址是自己lo接口上的VIP，所以会处理次请求报文，并将响应报文**通过lo接口送给eth0网卡直接发送给客户端**。注意：需要设置lo接口的VIP不能在共网上出现 



#### 5、四者的区别

| 机器名称   | IP配置                             | 服务角色   | 备注                               |
| ---------- | ---------------------------------- | ---------- | ---------------------------------- |
| lvs-server | VIP:172.16.100.1 DIP:192.168.100.1 | 负载均衡器 | 开启路由功能（VIP桥接、DIP仅主机） |
| rs01       | RIP：192.168.100.2                 | 后端服务器 | 网关指向DIP（仅主机）              |
| rs02       | RIP：192.168.100.3                 | 后端服务器 | 网关指向DIP（仅主机）              |
| rs03       | RIP：192.168.100.4                 | 后端服务器 | 网关指向DIP（仅主机）              |

lvs-nat与lvs-fullnat：请求和响应报文都经由Director

   　　lvs-nat：RIP的网关要指向DIP

  　　 lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信

lvs-dr与lvs-tun：请求报文要经由Director，但响应报文由RS直接发往Client

  　　 lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发

  　　 lvs-tun：通过在原IP报文外封装新IP头实现转发，支持远距离通信 

### 4、LVS ipvsadm 命令的使用

安装 lvs 管理软件

```shell
[root@qfedu.com ~]# yum -y install ipvsadm
```

命令选项

```shell
-A --add-service #在服务器列表中新添加一条新的虚拟服务器记录
-t #表示为tcp服务
-u #表示为udp服务
-s --scheduler #使用的调度算法， rr | wrr | lc | wlc | lblb | lblcr | dh | sh | sed | nq 默认调度算法是 wlc
例：ipvsadm -A -t 192.168.1.2:80 -s wrr

-a --add-server  #在服务器表中添加一条新的真实主机记录
-t --tcp-service #说明虚拟服务器提供tcp服务
-u --udp-service #说明虚拟服务器提供udp服务
-r --real-server #真实服务器地址
-m --masquerading #指定LVS工作模式为NAT模式
-w --weight #真实服务器的权值
-g --gatewaying #指定LVS工作模式为直接路由器模式（也是LVS默认的模式）
-i --ip #指定LVS的工作模式为隧道模式
-p #会话保持时间，定义流量被转到同一个realserver的会话存留时间
例：ipvsadm -a -t 192.168.1.2:80 -r 192.168.2.10:80 -m -w 1

-E -edit-service #编辑内核虚拟服务器表中的一条虚拟服务器记录。
-D -delete-service #删除内核虚拟服务器表中的一条虚拟服务器记录。
-C -clear #清除内核虚拟服务器表中的所有记录。
-R -restore #恢复虚拟服务器规则
-S -save #保存虚拟服务器规则，输出为-R 选项可读的格式
-e -edit-server #编辑一条虚拟服务器记录中的某条真实服务器记录
-d -delete-server #删除一条虚拟服务器记录中的某条真实服务器记录
-L|-l –list #显示内核虚拟服务器表

--numeric, -n：#以数字形式输出地址和端口号
--exact： #扩展信息，精确值 
--connection，-c： #当前IPVS连接输出
--stats： #统计信息
--rate ： #输出速率信息

参数也可以从/proc/net/ip_vs*映射文件中查看
-Z –zero #虚拟服务表计数器清零（清空当前的连接数量等）
```

### 5、LVS的调度算法

##### 1、静态算法（4种）

只根据算法进行调度 而不考虑后端服务器的实际连接情况和负载情况

**1、RR**：轮叫调度（Round Robin）

　 调度器通过”轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载｡

**2、WRR**：加权轮叫（Weight RR）

　 调度器通过“加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器处理更多的访问流量。调度器可以自动问询真实服务器的负载情况,并动态地调整其权值。

**3、DH**：目标地址散列调度（Destination Hash ）

　 根据请求的目标IP地址，作为散列键(HashKey)从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。

**4、SH**：源地址 hash（Source Hash）

　 源地址散列”调度算法根据请求的源IP地址，作为散列键(HashKey)从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空｡

##### 2、动态算法（6种）

前端的调度器会根据后端真实服务器的实际连接情况来分配请求

**1、LC**：最少链接（Least Connections）

　 调度器通过”最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用”最小连接”调度算法可以较好地均衡负载。

**2、WLC**：加权最少连接(默认采用的就是这种)（Weighted Least Connections）

　 在集群系统中的服务器性能差异较大的情况下，调度器采用“加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载｡调度器可以自动问询真实服务器的负载情况,并动态地调整其权值。

## LVS DR 模式搭建

**三台服务器A、B、C：**

#### A: load balancer

内网网卡：192.168.31.128，网关保持不变（192.168.31.2）

外网网卡：192.168.229.128，先不用理会，这里用不到

```shell
[root@a.qfedu.com ~]# setenforce 0 # 关闭selinux
[root@a.qfedu.com ~]# systemctl stop firewalld # 停止firewalld
[root@a.qfedu.com ~]# systemctl disable firewalld # 关闭firewalld
[root@a.qfedu.com ~]# yum install -y iptables-services # 安装iptables
[root@a.qfedu.com ~]# systemctl enable iptables # 添加iptables服务
[root@a.qfedu.com ~]# systemctl start iptables.service # 启动iptables服务
[root@a.qfedu.com ~]# iptables -F # 清空iptables规则
[root@a.qfedu.com ~]# service iptables save # 保存空规则
[root@a.qfedu.com ~]# yum -y install ipvsadm net-tools
```

1、创建 LVS 的 DR 规则脚本

```shell
写入以下内容：
[root@qfedu.com ~]# vim /usr/local/sbin/lvs_dr.sh
echo 1 > /proc/sys/net/ipv4/ip_forward # 临时打开路由转发
ipv=/usr/sbin/ipvsadm # 设置ipvsadm变量
vip=192.168.31.200 # 设置公用ip变量（virtual ip）
rs1=192.168.31.129 # 设置real server1ip的变量
rs2=192.168.31.130 # 设置real server2ip的变量
ifdown eth0 # 关闭网卡
ifup eth0 # 启动网卡，目的时清空临时设定的ip，避免重复设定
ifconfig eth0:2 $vip broadcast $vip netmask 255.255.255.255 up # 绑定vip到虚拟网卡eth0:2上
route add -host $vip dev eth0:2 # 为eth0:2网卡添加网关
$ipv -C # 清空规则
$ipv -A -t $vip:80 -s wrr # -A指定转发模式，-t指定director ip，-s指定调度算法 wrr加权轮询调度
$ipv -a -t $vip:80 -r $rs1:80 -g -w 1
# 指定转发规则，-a指定转发规则，-t指定调度器(director)ip，-r指定real server IP，-g指定转发模式为DR(gateway) -w指定权重
$ipv -a -t $vip:80 -r $rs2:80 -g -w 1
# 指定转发规则，-a指定转发规则，-t指定调度器(director)ip，-r指定real server IP，-g指定转发模式为DR(gateway) -w指定权重

例子：
#!/bin/bash
echo 1 > /proc/sys/net/ipv4/ip_forward
ipv=/usr/sbin/ipvsadm
vip=192.168.152.200
rs1=192.168.152.132
rs2=192.168.152.133
ifdown eth0
ifup eth0
ifconfig eth0:2 $vip broadcast $vip netmask 255.255.255.255 up
route add -host $vip dev eth0:2
$ipv -C
$ipv -A -t $vip:80 -s wrr
$ipv -a -t $vip:80 -r $rs1:80 -g -w 1
$ipv -a -t $vip:80 -r $rs2:80 -g -w 1
```

2、给脚本设权

```shell
[root@a.qfedu.com ~]# chmod 755 /usr/local/sbin/lvs_dr.sh
```

3、执行脚本

```shell
[root@a.qfedu.com ~]# sh /usr/local/sbin/lvs_dr.sh
```

4、查看路由上的 vip

```shell
[root@a.qfedu.com ~]# route -n
```

5、查看网卡 eth0 上的 vip

```shell
[root@a.qfedu.com ~]# ip addr
```

#### B: real server 

（web服务器） 内网网卡：192.168.31.129 网关改回129.168.31.2

安装nginx，并启动，在默认主页里写入，real server 1 关闭selinux，清空防火墙规则

1、创建转发脚本

```shell
[root@b.qfedu.com ~]# yum -y install net-tools

[root@b.qfedu.com ~]# vim /usr/local/sbin/lvs_rs.sh

写入以下内容：
#/bin/bash
vip=192.168.31.200
#把vip绑定在lo上，是为了实现rs直接把结果返回给客户端
ifdown lo
ifup lo
ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up绑定vip到虚拟网卡lo:0上
route add -host $vip lo:0为lo:0网卡添加网关
#以下操作为更改arp内核参数，目的是为了让rs顺利发送mac地址给客户端
echo "1" >/proc/sys/net/ipv4/conf/lo/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/lo/arp_announce
echo "1" >/proc/sys/net/ipv4/conf/all/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/all/arp_announce

arp_ignore:定义对目标地址为本地IP的ARP询问不同的应答模式0 
0 - (默认值): 回应任何网络接口上对任何本地IP地址的arp查询请求 
1 - 只回答目标IP地址是来访网络接口本地地址的ARP查询请求 
2 -只回答目标IP地址是来访网络接口本地地址的ARP查询请求,且来访IP必须在该网络接口的子网段内 
3 - 不回应该网络界面的arp请求，而只对设置的唯一和连接地址做出回应 
4-7 - 保留未使用 
8 -不回应所有（本地地址）的arp查询

arp_announce:对网络接口上，本地IP地址的发出的，ARP回应，作出相应级别的限制: 确定不同程度的限制,宣布对来自本地源IP地址发出Arp请求的接口 
0 - (默认) 在任意网络接口（eth0,eth1，lo）上的任何本地地址 
1 -尽量避免不在该网络接口子网段的本地地址做出arp回应. 当发起ARP请求的源IP地址是被设置应该经由路由达到此网络接口的时候很有用.此时会检查来访IP是否为所有接口上的子网段内ip之一.如果改来访IP不属于各个网络接口上的子网段内,那么将采用级别2的方式来进行处理. 
2 - 对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址.首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址. 如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送.

关于对arp_announce 理解的一点补充
其实就是路由器的问题，因为路由器一般是动态学习ARP包的（一般动态配置DHCP的话），当内网的机器要发送一个到外部的ip包，那么它就会请求 路由器的Mac地址，发送一个arp请求，这个arp请求里面包括了自己的ip地址和Mac地址，而linux默认是使用ip的源ip地址作为arp里面 的源ip地址，而不是使用发送设备上面的 ，这样在lvs这样的架构下，所有发送包都是同一个VIP地址，那么arp请求就会包括VIP地址和设备 Mac，而路由器收到这个arp请求就会更新自己的arp缓存，这样就会造成ip欺骗了，VIP被抢夺，所以就会有问题。 
arp缓存为什么会更新了，什么时候会更新呢，为了减少arp请求的次数，当主机接收到询问自己的arp请求的时候，就会把源ip和源Mac放入自 己的arp表里面，方便接下来的通讯。如果收到不是询问自己的包（arp是广播的，所有人都收到），就会丢掉，这样不会造成arp表里面无用数据太多导致 有用的记录被删除。  
在设置参数的时候将arp_ignore 设置为1，意味着当别人的arp请求过来的时候，如果接收的设备上面没有这个ip，就不做出响应，默认是0，只要这台机器上面任何一个设备上面有这个ip，就响应arp请求，并发送mac地址

例子：
#/bin/bash
vip=192.168.152.200
ifdown lo
ifup lo
ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up
route add -host $vip lo:0
echo "1" >/proc/sys/net/ipv4/conf/lo/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/lo/arp_announce
echo "1" >/proc/sys/net/ipv4/conf/all/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/all/arp_announce
```

2、给脚本设权

```shell
[root@b.qfedu.com ~]# chmod 755 /usr/local/sbin/lvs_rs.sh
```

3、执行脚本

```shell
[root@b.qfedu.com ~]# sh /usr/local/sbin/lvs_rs.sh
```

4、查看路由上的 vip

```shell
[root@b.qfedu.com ~]# route -n
```

5、查看网卡 lo 上的 vip

```shell
[root@b.qfedu.com ~]# ip addr
```

#### C: real server 

（web服务器） 内网网卡：192.168.31.130 网关改回129.168.31.2

安装nginx，并启动，在默认主页里写入，real server 2 关闭selinux，清空防火墙规则

1、创建转发脚本

```shell
[root@c.qfedu.com ~]# yum -y install net-tools

[root@c.qfedu.com ~]# vim /usr/local/sbin/lvs_rs.sh

写入以下内容：
#/bin/bash
vip=192.168.31.200
#把vip绑定在lo上，是为了实现rs直接把结果返回给客户端
ifdown lo
ifup lo
ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up绑定vip到虚拟网卡lo:0上
route add -host $vip lo:0为lo:0网卡添加网关
#以下操作为更改arp内核参数，目的是为了让rs顺利发送mac地址给客户端
echo "1" >/proc/sys/net/ipv4/conf/lo/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/lo/arp_announce
echo "1" >/proc/sys/net/ipv4/conf/all/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/all/arp_announce

arp_ignore:定义对目标地址为本地IP的ARP询问不同的应答模式0 
0 - (默认值): 回应任何网络接口上对任何本地IP地址的arp查询请求 
1 - 只回答目标IP地址是来访网络接口本地地址的ARP查询请求 
2 -只回答目标IP地址是来访网络接口本地地址的ARP查询请求,且来访IP必须在该网络接口的子网段内 
3 - 不回应该网络界面的arp请求，而只对设置的唯一和连接地址做出回应 
4-7 - 保留未使用 
8 -不回应所有（本地地址）的arp查询

arp_announce:对网络接口上，本地IP地址的发出的，ARP回应，作出相应级别的限制: 确定不同程度的限制,宣布对来自本地源IP地址发出Arp请求的接口 
0 - (默认) 在任意网络接口（eth0,eth1，lo）上的任何本地地址 
1 -尽量避免不在该网络接口子网段的本地地址做出arp回应. 当发起ARP请求的源IP地址是被设置应该经由路由达到此网络接口的时候很有用.此时会检查来访IP是否为所有接口上的子网段内ip之一.如果改来访IP不属于各个网络接口上的子网段内,那么将采用级别2的方式来进行处理. 
2 - 对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址.首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址. 如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送.

关于对arp_announce 理解的一点补充
其实就是路由器的问题，因为路由器一般是动态学习ARP包的（一般动态配置DHCP的话），当内网的机器要发送一个到外部的ip包，那么它就会请求 路由器的Mac地址，发送一个arp请求，这个arp请求里面包括了自己的ip地址和Mac地址，而linux默认是使用ip的源ip地址作为arp里面 的源ip地址，而不是使用发送设备上面的 ，这样在lvs这样的架构下，所有发送包都是同一个VIP地址，那么arp请求就会包括VIP地址和设备 Mac，而路由器收到这个arp请求就会更新自己的arp缓存，这样就会造成ip欺骗了，VIP被抢夺，所以就会有问题。 
arp缓存为什么会更新了，什么时候会更新呢，为了减少arp请求的次数，当主机接收到询问自己的arp请求的时候，就会把源ip和源Mac放入自 己的arp表里面，方便接下来的通讯。如果收到不是询问自己的包（arp是广播的，所有人都收到），就会丢掉，这样不会造成arp表里面无用数据太多导致 有用的记录被删除。  
在设置参数的时候将arp_ignore 设置为1，意味着当别人的arp请求过来的时候，如果接收的设备上面没有这个ip，就不做出响应，默认是0，只要这台机器上面任何一个设备上面有这个ip，就响应arp请求，并发送mac地址

例子：
#/bin/bash
vip=192.168.152.200
ifdown lo
ifup lo
ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up
route add -host $vip lo:0
echo "1" >/proc/sys/net/ipv4/conf/lo/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/lo/arp_announce
echo "1" >/proc/sys/net/ipv4/conf/all/arp_ignore
echo "2" >/proc/sys/net/ipv4/conf/all/arp_announce
```

2、给脚本设权

```shell
[root@c.qfedu.com ~]# chmod 755 /usr/local/sbin/lvs_rs.sh
```

3、执行脚本

```shell
[root@c.qfedu.com ~]# sh /usr/local/sbin/lvs_rs.sh
```

4、查看路由上的 vip

```shell
[root@c.qfedu.com ~]# route -n
```

5、查看网卡 lo 上的 vip

```shell
[root@c.qfedu.com ~]# ip addr
```

#### 测试

浏览器里访问192.168.31.200，（vip:vitrual ip）多刷新几次看结果，服务器的切换。

浏览器上因为有本地缓存的原因，虽已经设定了登陆保持时限为1秒，但每次刷新都会保持在real server 2主机上。可以在调度机里用 curl 192.168.31.200 测试访问，调度算法采用rr，效果更明显。

1、用 ipvsadm 命令查看转发规则

```shell
[root@a.qfedu.com  ~]# ipvsadm -ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
-> RemoteAddress:Port Forward Weight ActiveConn InActConn
TCP 192.168.31.200:80 wrr
-> 192.168.31.129:80 Route 1 0 4
-> 192.168.31.130:80 Route 1 0 5

# ActiveConn是活动连接数,也就是tcp连接状态的ESTABLISHED;InActConn是指除了ESTABLISHED以外的,所有的其它状态的tcp连接
```

2、查看 iptables nat 链的转发规则

```shell
[root@a.qfedu.com  ~]# iptables -t nat -nvL
Chain PREROUTING (policy ACCEPT 89 packets, 13284 bytes)
pkts bytes target prot opt in out source destination

Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
pkts bytes target prot opt in out source destination

Chain OUTPUT (policy ACCEPT 40 packets, 4692 bytes)
pkts bytes target prot opt in out source destination

Chain POSTROUTING (policy ACCEPT 7 packets, 2296 bytes)
pkts bytes target prot opt in out source destination
48 3648 MASQUERADE all -- * * 192.168.31.0/24 0.0.0.0/0
```

