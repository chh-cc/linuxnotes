# 持久化

## 简介

持久化主要是做**灾难恢复、数据恢复**，也可以归类到高可用的一个环节中去，比如你 Redis 整个挂了，然后 Redis 就不可用了，你要做的事情就是让 Redis 变得可用，尽快变得可用。

重启 Redis，尽快让它对外提供服务，如果没做数据备份，这时候 Redis 启动了，也不可用啊，数据都没了。

很可能说，大量的请求过来，缓存全部无法命中，在 Redis 里根本找不到数据，这个时候就死定了，出现**缓存雪崩**问题。所有请求没有在 Redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 mysql 承接高并发，然后就挂了...

如果你把 Redis 持久化做好，备份和恢复方案做到企业级的程度，那么即使你的 Redis 故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务。

通过 RDB 或 AOF，都可以将 Redis 内存中的数据给**持久化到磁盘**上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。

## RDB持久化（全量写入）

可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。

对 Redis 中的数据执行**周期性**的持久化。

在默认情况下， Redis 将数据库快照保存在名字为 **dump.rdb**的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， **自动保存**一次数据集。

你也可以通过调用 SAVE或者 BGSAVE ， **手动**让 Redis 进行数据集保存操作。

当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:

1、Redis 调用forks. 同时拥有父进程和子进程。

2、子进程将数据集写入到一个临时 RDB 文件中。

3、当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。

### 优点

- RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
- 定时生成 RDB 快照（snapshot）非常便于进行数据库冷备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快

### 缺点

- 如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。


- 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。


- 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时，fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。

### 备份Redis

Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制：

RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。

   这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。

- 创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。


- 确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。


- 至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。

### 配置

redis.conf文件

```shell
#注释所有save行则停止rdb持久化
#900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）
save 900 1
#300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）
save 300 10
#60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）
save 60 10000

#后台备份进程出错时,主进程停不停止写入? 主进程不停止容易造成数据不一致
stop-writes-on-bgsave-error yes
#是否压缩rdb文件，rdb文件压缩使用LZF压缩算法，压缩会消耗一些cpu，不压缩文件会很大
rdbcompression yes
#导出来的rdb文件名
dbfilename dump.rdb
#rdb的放置路径
dir ./clsn/redis/data/6379
#导入rbd恢复时数据时,要不要检验rdb的完整性 验证版本是不是一致
rdbchecksum yes
```

### 触发

1.手动执行bgsave命令
2.根据配置文件的save选项自动触发
3.主从结构时，从节点执行全量复制操作，主节点自动执行，将生成的RDB文件发送给从
4.执行debug reload命令重新加载Redis时
5.默认情况下执行shutdown命令关闭redis时，如果没有开启AOF持久化功能则自动执行

### 恢复

1.将RDB备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。

2.上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。

## AOF持久化（增量写入）

过程:

- 1）所有的写入命令会追加到aof_buf（缓冲区）中。
- 2）AOF缓冲区根据对应的策略向硬盘做同步操作。
- 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。
- 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会**优先使用 AOF** 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集**更完整**。

### 优点

- 使用 AOF 会让你的 Redis 更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.

### 缺点

- 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。

### 配置

```shell
#是否开启aof持久化。默认no，要打开
appendonly yes
#位置
appendfilename "appendonly.aof"

#每次有数据修改发生时都立即写入AOF文件
#appendfsync always

#每秒钟同步一次，该策略为AOF的缺省策略
appendfsync everysec

#不加入缓冲区，直接写到硬盘，速度最快，不安全
#appendfsync no

#正在导出rdb快照的过程中,要不要停止同步 aof
no-appendfsync-on-rewrite yes/no

#新的aof文件大小是上次的aof文件的大小2倍（100）时，进行重写
auto-aof-rewrite-percentage 100

#aof文件,至少超过64M时,重写
auto-aof-rewrite-min-size 64mb
```

### 恢复

- 将AOF备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。
- 上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。

## RDB 和 AOF 到底该如何选择

- 不要仅仅使用 RDB，因为那样会导致你**丢失很多数据**；
- 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的**恢复速度**更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；
- Redis 支持**同时开启两种**持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择；用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。