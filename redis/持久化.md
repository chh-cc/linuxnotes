# 持久化

## 简介

Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，**将数据保存到磁盘上**，当redis重启后，可以从磁盘中恢复数据。

redis 提供了两种不同级别的持久化方式:一种是**RDB**,另一种是**AOF**.

## RDB持久化（全量写入）

可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。

在默认情况下， Redis 将数据库快照保存在名字为 **dump.rdb**的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， **自动保存**一次数据集。

你也可以通过调用 SAVE或者 BGSAVE ， **手动**让 Redis 进行数据集保存操作。

当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:

1、Redis 调用forks. 同时拥有父进程和子进程。

2、子进程将数据集写入到一个临时 RDB 文件中。

3、当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。

### 优点

- RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
- 定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快

### 缺点

- 如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。


- 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。


- 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时，fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。

### 备份Redis

Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制：

RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。

   这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。

- 创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。


- 确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。


- 至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。

### 配置

redis.conf文件

```shell
#注释所有save行则停止rdb持久化
#900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）
save 900 1
#300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）
save 300 10
#60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）
save 60 10000

#后台备份进程出错时,主进程停不停止写入? 主进程不停止容易造成数据不一致
stop-writes-on-bgsave-error yes
#是否压缩rdb文件，rdb文件压缩使用LZF压缩算法，压缩会消耗一些cpu，不压缩文件会很大
rdbcompression yes
#导出来的rdb文件名
dbfilename dump.rdb
#rdb的放置路径
dir ./clsn/redis/data/6379
#导入rbd恢复时数据时,要不要检验rdb的完整性 验证版本是不是一致
rdbchecksum yes
```

### 触发

1.手动执行bgsave命令
2.根据配置文件的save选项自动触发
3.主从结构时，从节点执行全量复制操作，主节点自动执行，将生成的RDB文件发送给从
4.执行debug reload命令重新加载Redis时
5.默认情况下执行shutdown命令关闭redis时，如果没有开启AOF持久化功能则自动执行

### 恢复

1.将RDB备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。

2.上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。

## AOF持久化（增量写入）

过程:

- 1）所有的写入命令会追加到aof_buf（缓冲区）中。
- 2）AOF缓冲区根据对应的策略向硬盘做同步操作。
- 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。
- 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会**优先使用 AOF** 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集**更完整**。

### 优点

- 使用 AOF 会让你的 Redis 更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据.

### 缺点

- 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。

### 配置

```shell
#是否开启aof持久化。默认no，要打开
appendonly yes
#位置
appendfilename "appendonly.aof"

#每次有数据修改发生时都立即写入AOF文件
#appendfsync always

#每秒钟同步一次，该策略为AOF的缺省策略
appendfsync everysec

#不加入缓冲区，直接写到硬盘，速度最快，不安全
#appendfsync no

#正在导出rdb快照的过程中,要不要停止同步 aof
no-appendfsync-on-rewrite yes/no

#新的aof文件大小是上次的aof文件的大小2倍（100）时，进行重写
auto-aof-rewrite-percentage 100

#aof文件,至少超过64M时,重写
auto-aof-rewrite-min-size 64mb
```

### 恢复

- 将AOF备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。
- 上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。

## 总结

二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。

启动加载流程：

- AOF持久化开启且存在AOF文件时， 优先加载AOF文件
- AOF关闭或者AOF文件不存在时， 加载RDB文件
- 加载AOF/RDB文件成功后， Redis启动成功
- AOF/RDB文件存在错误时， Redis启动失败并打印错误信息