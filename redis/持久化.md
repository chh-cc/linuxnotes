# 持久化

## 简介

Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。

## RDB持久化（全量写入）

### 原理

`RDB`持久化是把当前进程数据生成快照保存到硬盘的过程，触发`RDB`持久化过程分为手动触发和自动触发

![file](https://cdn.jsdelivr.net/gh/chh-cc/linuxnotes//img/20210206214843.png)

- 1）执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回。
- 2）父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒。
- 3）父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。
- 4）子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换 执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项。
- 5）进程发送信号给父进程表示完成，父进程更新统计信息，具体见info Persistence下的rdb_*相关选项。

### 配置

redis.conf文件

```text
#注释所有save行则停止rdb持久化
#900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）
save 900 1
#300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）
save 300 10
#60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）
save 60 10000
#当RDB持久化出现错误后，再写入数据会报错，用于提示用户出问题了。
#yes是开启，no是关闭，默认开启
stop-writes-on-bgsave-error yes
#是否压缩rdb文件，rdb文件压缩使用LZF压缩算法，压缩会消耗一些cpu，不压缩文件会很大
#yes开启，no关闭，默认开启
rdbcompression yes
#使用CRC64算法来进行数据校验，防止RDB是错误的，但是这样做会增加大约10%的性能消耗
#yes开启，no关闭，默认开启
rdbchecksum yes
```

### 触发

1.手动执行bgsave命令
2.根据配置文件的save选项自动触发
3.主从结构时，从节点执行全量复制操作，主节点自动执行，将生成的RDB文件发送给从
4.执行debug reload命令重新加载Redis时
5.默认情况下执行shutdown命令关闭redis时，如果没有开启AOF持久化功能则自动执行

### 恢复

1.将RDB备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。

2.上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。

## AOF持久化（增量写入）

### 原理

以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的**实时性**，目前已经是Redis持久化的**主流**方式。

![file](https://cdn.jsdelivr.net/gh/chh-cc/linuxnotes//img/20210206215626.png)

- 1）所有的写入命令会追加到aof_buf（缓冲区）中。
- 2）AOF缓冲区根据对应的策略向硬盘做同步操作。
- 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。
- 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

### 配置

```text
#是否开启aof持久化。默认no，要打开
appendonly yes
#位置
appendfilename "appendonly.aof"
#每次有数据修改发生时都会写入AOF文件
#命令写入aof_buf后调用系统fsync操作同步AOF文件，fsync完成后线程返回
#appendfsync always

#每秒钟同步一次，该策略为AOF的缺省策略
#命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由专门线程每秒调用一次
#这个模式兼顾了效率的同时也保证了数据的完整性，即使在服务器宕机也只会丢失一秒内对redis数据库做的修改
appendfsync everysec

#不加入缓冲区，直接写到硬盘，速度最快，不安全
#命令写入aof_buf后调用系统write操作，不对aof文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒
#这种模式下效率是最快的，但对数据来说也是最不安全的，如果redis里的数据都是从后台数据库如mysql中取出来的，属于随时可以找回或者不重要的数据，那么可以考虑设置成这种模式。
#appendfsync no
```

### 触发

执行bgrewriteaof手动触发

配置文件触发：

```text
#新的aof文件大小是上次的aof文件的大小2倍（100）时，进行重写
auto-aof-rewrite-percentage 100
#表示运行AOF重写时文件最小体积， 默认为64MB
auto-aof-rewrite-min-size 64mb
```

### 恢复

- 将AOF备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。
- 上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。
- 可以使用pipline方式批量硬写入，但效率会低

## 总结

二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。

启动加载流程：

- AOF持久化开启且存在AOF文件时， 优先加载AOF文件
- AOF关闭或者AOF文件不存在时， 加载RDB文件
- 加载AOF/RDB文件成功后， Redis启动成功
- AOF/RDB文件存在错误时， Redis启动失败并打印错误信息