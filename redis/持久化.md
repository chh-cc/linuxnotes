# 持久化

假设现在你有一个业务应用，需要引入 Redis 来提高应用的性能，此时你可以选择部署一个单机版的 Redis 来使用

![image-20210709100015183](https://gitee.com/c_honghui/picture/raw/master/img/20210709100021.png)

把 Redis 当做缓存来使用，从 MySQL 中查询数据，然后写入到 Redis 中，之后业务应用再从 Redis 中读取这些数据，由于 Redis 的数据都存储在内存中，所以这个速度飞快。

有一天，你的 Redis 因为某些原因宕机了，这时你的所有业务流量，都会打到后端 MySQL 上，这会导致你的 MySQL 压力剧增，严重的话甚至会压垮 MySQL。

这时如果重启Redis虽然能正常工作,但是数据都丢失了,业务流量还是打到MySQL上

如果把内存数据写到磁盘上,当Redis重启时把磁盘的数据快速恢复到内存中,就可以继续提供服务.



通过 RDB 或 AOF，都可以将 Redis 内存中的数据给**持久化到磁盘**上面来，然后可以将这些数据备份到别的地方去，比如说阿里云等云服务。

## RDB持久化（全量写入）

Redis 的数据快照，是记录**某一时刻**下 Redis 中的数据，然后只需要把这个数据快照写到磁盘上就可以了(创建一个子进程来做)。

优势在于，只在需要持久化时，把数据「一次性」写入磁盘，其它时间都不需要操作磁盘。



在默认情况下， Redis 将数据库快照保存在名字为 **dump.rdb**的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， **自动保存**一次数据集。

你也可以通过调用 SAVE或者 BGSAVE ， **手动**让 Redis 进行数据集保存操作。

当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:

1、Redis 调用forks. 同时拥有父进程和子进程。

2、子进程将数据集写入到一个临时 RDB 文件中。

3、当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。

### 特点

RDB采用二进制+数据压缩方式写磁盘,这样文件体积小,**数据恢复快**

如果你的业务对于数据丢失不敏感，采用 RDB 方案持久化数据

### 备份Redis

Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制：

RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。

   这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。

- 创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。


- 确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。


- 至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。

### 配置

redis.conf文件

```shell
#注释所有save行则停止rdb持久化
#900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）
save 900 1
#300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）
save 300 10
#60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）
save 60 10000

#后台备份进程出错时,主进程停不停止写入? 主进程不停止容易造成数据不一致
stop-writes-on-bgsave-error yes
#是否压缩rdb文件，rdb文件压缩使用LZF压缩算法，压缩会消耗一些cpu，不压缩文件会很大
rdbcompression yes
#导出来的rdb文件名
dbfilename dump.rdb
#rdb的放置路径
dir ./clsn/redis/data/6379
#导入rbd恢复时数据时,要不要检验rdb的完整性 验证版本是不是一致
rdbchecksum yes
```

### 触发

1.手动执行bgsave命令
2.根据配置文件的save选项自动触发
3.主从结构时，从节点执行全量复制操作，主节点自动执行，将生成的RDB文件发送给从
4.执行debug reload命令重新加载Redis时
5.默认情况下执行shutdown命令关闭redis时，如果没有开启AOF持久化功能则自动执行

### 恢复

1.将RDB备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。

2.上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。

## AOF持久化（增量写入）

Redis 写内存由主线程来做，写内存完成后就给客户端返回结果，然后 Redis 用另一个线程把**每一次写操作**持久化到磁盘，这样就可以避免主线程写磁盘对性能的影响。

过程:

- 1）所有的写入命令会追加到aof_buf（缓冲区）中。
- 2）AOF缓冲区根据对应的策略向硬盘做同步操作。
- 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。

### 特点

如果你的业务对数据完整性要求比较高，采用 AOF 方案持久化数据

AOF 记录的是每一次写命令，数据最全，但文件体积大，**数据恢复速度慢**

如何缩小文件体积?

AOF 文件中记录的都是每一次写操作，但对于同一个 key 可能会发生多次修改，我们只保留最后一次被修改的值,这就是我们经常听到的「AOF rewrite」.我们可以对 AOF 文件定时 rewrite，避免这个文件体积持续膨胀

### 配置

```shell
#是否开启aof持久化。默认no，要打开
appendonly yes
#位置
appendfilename "appendonly.aof"

#每次有数据修改发生时都立即写入AOF文件
#appendfsync always

#每秒钟同步一次，该策略为AOF的缺省策略
appendfsync everysec

#不加入缓冲区，直接写到硬盘，速度最快，不安全
#appendfsync no

#正在导出rdb快照的过程中,要不要停止同步 aof
no-appendfsync-on-rewrite yes/no

#新的aof文件大小是上次的aof文件的大小2倍（100）时，进行重写
auto-aof-rewrite-percentage 100

#aof文件,至少超过64M时,重写
auto-aof-rewrite-min-size 64mb
```

### 恢复

- 将AOF备份放到配置文件指定的数据目录下，启动redis将会自动恢复。**加载期间将会阻塞**，无法进行其它操作。
- 上述方法不行，或者恢复的集群，可以使用[redis-migrate-tool](http://www.52wiki.cn/docs/redis/redis-1albdpdf7jgt8)工具进行恢复。

## 混合持久化(4.0以上)

当 AOF rewrite 时，Redis 先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在这期间产生的每一个写命令，追加到 AOF 文件中。因为 RDB 是二进制压缩写入的，这样 AOF 文件体积就变得更小了。

![image-20210709110918938](https://gitee.com/c_honghui/picture/raw/master/img/20210709110919.png)

此时，你在使用 AOF 文件恢复数据时，这个恢复时间就会更短了！

Redis 4.0 以上版本才支持混合持久化。

