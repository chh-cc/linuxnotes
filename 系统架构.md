# 系统架构

一个好的软件架构应该遵循以下 3 个原则：

- 高性能
- 高可用
- 易扩展

## 单机架构

业务起步，体量小时：

应用——读/写→数据库

客户端请求进来，业务应用读写数据库，返回结果

避免单节点故障丢失数据，解决方案是定期备份，但恢复需要时间，且数据不完整

## 主从架构

在另一台机器上，再部署一个数据库实例，让两者保持「实时同步」

特点：

- 数据完整性高
- 抗故障能力提升
- 读性能提升

「业务应用」也可以在其它机器部署一份，避免单点。因为业务应用通常是「无状态」的（不像数据库那样存储数据），所以直接部署即可

因为业务应用部署了多个，所以还需要部署一个「负载均衡」（一般会使用 nginx 或 LVS），这样当一台机器宕机后，另一台机器也可以「接管」所有流量，持续提供服务。

风险：同机柜/机房

## 同城灾备

需要做机房级别的冗余方案，另一个机房处于待命状态：

- 两个机房的网络用一条「专线」连通
- 在另一个机房用主从架构方式部署数据副本
- 在另一个机房部署好接入层、业务应用

当A 机房整个挂掉，我们只需要做 2 件事即可：

- B 机房所有从库提升为主库
- DNS 指向 B 机房，接入流量，业务恢复

## 同城双活

需要让 B 机房也接入流量，实时提供服务，这样做的好处，**一是可以实时训练这支后备军，让它达到与 A 机房相同的作战水平，随时可切换，二是 B 机房接入流量后，可以分担 A 机房的流量压力**。

怎么让 B 机房也接入流量呢？很简单，就是把 B 机房的接入层 IP 地址，加入到 DNS 中

业务应用在操作数据库时，需要区分「**读写分离**」（一般用中间件实现），即两个机房的「读」流量，可以读任意机房的存储，但「写」流量，只允许写 A 机房，因为主库在 A 机房。

## 两地三中心

通常建议两个机房的距离要在 1000 公里以上，这样才能应对城市级别的灾难。

**两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备。**

问题：启用灾备机房需要时间，而且启用后的服务，不确定能否如期工作

## 异地双活

异地双活不能直接「照搬」同城双活的模式去部署，这样的话如果上海的机房去请求北京机房的存储，会存在网络延迟高

所以两个机房的存储必须都是「**主库**」，而且两个机房的数据还要「**互相同步**」数据

MySQL 本身就提供了双主架构，它支持双向复制数据，但平时用的并不多。而且 Redis、MongoDB 等数据库并没有提供这个功能，所以，你必须开发对应的「**数据同步中间件**」来实现双向同步的功能。

业界也开源出了很多数据同步中间件，例如阿里的 Canal、RedisShake、MongoShake，可分别在两个机房同步 MySQL、Redis、MongoDB 数据。

问题：

在很短的时间内，同一个用户修改同一条数据，两个机房无法确认谁先谁后，数据发生「冲突」。

解决：

在接入层之上，再部署一个「路由层」（通常部署在云服务器上），自己可以配置路由规则，把用户「分流」到不同的机房内。

1. 按业务类型分片
2. 直接哈希分片
3. 按地理位置分片