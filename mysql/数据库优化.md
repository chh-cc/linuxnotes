# 数据库优化

现如今，数据库的操作越来越成为**整个应用的性能瓶颈**了，这点对于Web应用尤其明显，所以要重视数据库的性能优化。

一个成熟的数据库架构并不是一开始设计就具备高可用、高伸缩等特性的，它是随着用户量的增加，基础架构才**逐渐完善**。



SQL执行慢原因：

- 网络速度慢，内存不足，I/O吞吐量小，磁盘空间满了等硬件问题
- 数据库整体结构已经扛不住压力
- 没有索引或者索引失效
- 数据表里的数据记录过多
- 服务器调优及各个参数设置也可能会影响
- 开发者编写的SQL效率
- 其它

常见瓶颈：

\1. cpu SQL中对大量数据进行比较、关联、排序、分组，其中最大的压力在于'比较'

\2. IO 实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO。使用交换内存 查询执行效率低，扫描过多数据行。

\3. 锁 不适宜的锁的设置，导致线程阻塞，性能下降。 死锁，线程之间交叉调用资源，导致死锁，程序卡住



优化范围和思路

```text
优化范围：
存储、主机和操作系统:
    主机架构稳定性
    I/O规划及配置
    Swap
    OS内核参数
    网络问题
应用程序:（Index，lock，session）
    应用程序稳定性和性能
    SQL语句性能
    串行访问资源
    性能欠佳会话管理
数据库优化:（内存、数据库设计、参数）
    内存
    数据库结构(物理&逻辑)
    实例配置
```



## 数据库表设计

表结构设计很重要，如果设计不当，会直接影响到用户访问网站速度，用户体验不好

影响因素有很多，例如慢查询（低效的查询语句）、没有适当建立索引、数据库堵塞（锁）等。

**sql语句优化**
1.**EXPLAIN分析SELECT查询**
很多情况下，使用EXPLAIN关键字可以知道MySQL是如何处理SQL语句的，这可以帮助分析查询语句，从而或许能尽快的找到优化方法以及潜在的性能问题。

2.**SELECT查询****必须指明字段名**
SELECT * 的查询会加很多不必要的消耗（例如CPU、I/O等），同时，也有可能增加了使用覆盖索引。所以SELECT查询时，要求直接在后面指明需要查询的对应字段名。

3.**查询一条数据的时候，使用 LIMIT 1**
减少多余的查询，因为指定limit 1后，查询到一条数据就不再继续查询了，使得EXPLAIN中type列达到const类型，查询语句更优。

4.为搜索的**WHERE字段建立索引**
一般，每个表都会设置一个主键，而索引并不一定就是给主键。如果在表中，有某个字段总要会经常用来做WHERE查询搜索，而且是读大于写的。

5.千万不要使用 ORDER BY RAND()
如果想随机取数据，不要用用随机数取，因为这种查询，对数据库的性能毫无益处（消耗CPU）。更好的方案之一是先找到数据所在的条数N，然后再用LIMIT N, 1这样查询。

6.保证每张表都有一个**主键**ID
每设计新建一张表的时候，都应该为其设计一个ID字段，并让其成为主键，而且最好是INT型（也有使用UUID的），同时设置这个ID字段为自增（AUTO_INCREMENT）的标志。

7.尽可能的使用 NOT NULL
NULL也需要额外的空间，NULL字段在进行查询比较的时候，是比较麻烦的。如果不是必须使用NULL，就建议使用NOT NULL。

8.选择合适的存储引擎
在MySQL中有MyISAM和InnoDB两种存储引擎，两者各有利弊，需要了解两者的差异然后来做出最合适的选择，例如InnoDB支持事务而MyISAM不支持，MyISAM查询比InnoDB快等等；若不太清楚选择什么的话，那就用InnoDB。

9.把IP地址存为UNSIGNED INT
在遇到需要存储IP地址的时候，大多数想法都会是存储VARCHAR(15)字符串类型的，而不会想到要用INT整型来存储；如果用整型来存储，只需要4个字节，并且你可以有定长的字段，而且会带来查询上的优势。

10.尽量不要在WHERE查询时对字段进行null值判断
当对一个字段进行null的判断时候，会比较慢的，这是因为这个判断会导致引擎放弃使用所有已有的索引而进行全表扫描搜索。

11.尽量**不要使用%前缀**的LIKE模糊查询
模糊查询，在日常开发中会经常遇到，很多都是直接 LIKE ‘%key_word%’ 或者 LIKE ‘%key_word’ 这样搜索的，这两种搜索方式，都会导致索引失效从而进行全表扫描搜索。建议使用“全文索引”。

12.**避免在WHERE查询时对字段进行表达式操作**
例如查询语句SELECT id FROM table WHERE num * 2 = 50;，这样的查询，对字段num做了一个乘2的算数操作，就会导致**索引失效**。

13.减少不必要的排序
排序操作会消耗较多的CPU资源，所以减少不必要的排序可以在缓存命中率高等I/O足够的情况下，会降低SQL的响应时间。

14.建议**用JOIN代替子查询**
JOIN的性能相比子查询有更大优势。

15.避免发生隐式类型转换
类型转换主要是指在WHERE子句中出现字段的类型和传入的参数类型不一致的时候发生的类型转换；这是因为如果传入的数据类型和字段类型不一致，MySQL可能会对数据进行类型转换操作，也可能不进行处理而直接交由存储引擎去处理，这样一来，就可能会出现索引无法使用的情况而造成执行计划问题。

16.避免多表查询字段类型不一致
在遇到需要多表联合查询的时候，设计表结构的时候，尽量保持表与表的关联字段一致，并且都要设置索引。同时，多表连接查询时，尽量把结果集小的表作为驱动表。

17.**建议开启查询缓存**
大多数的MySQL服务器都开启了查询缓存，这是提高性能最有效的方法之一，因为查询缓存由MySQL数据库引擎自动处理，当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表，而直接访问缓存结果了。

18.使用UNION代替临时表
UNION查询可以把两条或更多的SELECT查询结果合并到一个查询中，从而不再需要创建临时表来完成。需要注意的是，使用UNION的所有SELECT语句中的字段数目要相同。

19.**慎用IN查询**
IN以及NOT IN查询都要慎重，因为可能会导致全表扫描，而对于连续的数值，能用BETWEEN就不要用IN了。

## 硬件优化

### 配置选择

硬盘：

MySQL每秒钟都在进行大量、复杂的查询操作，对磁盘的读写量可想而知。所以，通常认为磁盘I/O是制约MySQL性能的最大因素之一。解决这一制约因素可以考虑以下几种解决方案：

1. 使用RAID-0+1磁盘阵列，注意不要尝试使用RAID-5，性能会很差
2. 资金充足，可单独对数据库服务器选择固态方式来提高性能

CPU：

数据库对于CPU的需求没有内存这么大，通常64G内存，只需要8核CPU就可以了。如果是单实例的mysql，可以在/etc/grub.conf配置文件中，加入参数numa=off，禁用numa功能。

内存：

服务器内存建议不要小于8GB，用以应对高速增长的咨询等信息。建议2-3倍cpu核心数量。内存方面可以关闭swap功能， echo 0 >/proc/sys/vm/swappiness ，关闭swap功能

Linux内核有一个特性，会从物理内存中划分出缓存区（系统缓存和数据缓存）来存放热数据，通过文件系统延迟写入机制，等满足条件时（如缓存区大小到达一定百分比或者执行sync命令）才会同步到磁盘。

也就是说物理内存越大，分配缓存区越大，缓存数据越多，建议物理内存至少富裕50%以上。

## 参数优化

Mysql的最大并发连接数⭐

```ruby
show variables like 'max_connections';
    +-----------------+-------+
    | Variable_name   | Value |
    +-----------------+-------+
    | max_connections | 151   |
    +-----------------+-------+

使用以来最大连接数：    
show status like 'Max_used_connections';
    +----------------------+-------+
    | Variable_name        | Value |
    +----------------------+-------+
    | Max_used_connections | 101   |
    +----------------------+-------+
如果max_used_connections跟max_connections相同,那么就是max_connections设置过低或者超过服务器的负载上限了，低于10%则设置过大.     

vim /etc/my.cnf 
Max_connections=1024
```

mysql能暂存的连接数量

```dart
当mysql线程在一个很短时间内得到非常多的连接请求时候它就会起作用，如果mysql的连接数据达到max_connections时候，新来的请求将会被存在堆栈中，等待某一连接释放资源，该推栈的数量即back_log,如果等待连接的数量超过back_log，将不被授予连接资源。

show full processlist;
发现大量的待连接进程时，就需要加大back_log或者加大max_connections的值
    
vim /etc/my.cnf 
back_log=3000
```

wati_timeout⭐

```dart
（1）简介
wait_timeout：指的是mysql在关闭一个非交互的连接之前所要等待的秒数，默认28800s/8h
interactive_timeout：指的是mysql在关闭一个交互的连接之前所需要等待的秒数，比如我们在终端上进行mysql管理，使用的即交互的连接，这时候，如果没有操作的时间超过了interactive_time设置的时间就会自动的断开
wait_timeout:如果设置太小，那么连接关闭的就很快，从而使一些持久的连接不起作用
（2）设置建议
如果设置太大，容易造成连接打开时间过长，在show processlist时候，能看到很多的连接 ，一般希望wait_timeout尽可能低
（3）修改方式举例
wait_timeout=86400
长连接的应用，为了不去反复的回收和分配资源，降低额外的开销。
一般我们会将wait_timeout设定比较小，interactive_timeout要和应用开发人员沟通长链接的应用是否很多。如果他需要长链接，那么这个值可以不需要调整。
另外还可以使用类外的参数弥补。
```

索引缓冲区的大小⭐

```dart
（1）简介
myisam表的索引缓冲区
临时表的缓冲区

（2）设置依据
通过key_read_requests和key_reads可以直到key_baffer_size设置是否合理。
mysql> show variables like "key_buffer_size%";
+-----------------+---------+
| Variable_name   | Value   |
+-----------------+---------+
| key_buffer_size | 8388608 |8M
+-----------------+---------+
1 row in set (0.00 sec)

mysql> 
mysql> show status like "key_read%";
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Key_read_requests | 10    |
| Key_reads         | 2     |
+-------------------+-------+
2 rows in set (0.00 sec)

一共有10个索引读取请求，有2个请求在内存中没有找到直接从硬盘中读取索引
控制在 5%以内 。


查看临时表创建情况：                                             
mysql> show status like "created_tmp%";
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Created_tmp_disk_tables | 0     |磁盘
| Created_tmp_files       | 6     |
| Created_tmp_tables      | 1     |内存
+-------------------------+-------+
3 rows in set (0.00 sec)
mysql> 

Created_tmp_tables/(Created_tmp_disk_tables + Created_tmp_tables) 
Created_tmp_disk_tables/(Created_tmp_disk_tables + Created_tmp_tables) 控制在5%-10%以内

（3）配置方法
key_buffer_size=64M
```

私有内存（单个会话独享的，不能设置太高）

```text
sort_buffer_size 排序的线程分配缓冲区（order by、group by、distinct、union），应该去优化索引
join_buffer_size 表关联缓存大小，尽量在sql优化
read_buffer_size 顺序扫描分配读入缓冲区大小
```

查询缓存大小

```bash
（1）简介：
查询缓存简称QC，使用查询缓冲，mysql将查询结果存放在缓冲区中，今后对于同样的select语句（区分大小写）,将直接从缓冲区中读取结果。

SQL层：
select * from t1 where name=:NAME;
select * from t1 where name=:NAME;

1、查询完结果之后，会对SQL语句进行hash运算，得出hash值,我们把他称之为SQL_ID
2、会将存储引擎返回的结果+SQL_ID存储到缓存中。

存储方式：
例子：select * from t1  where id=10;      100次

1、将select * from t1  where id=10; 进行hash运算计算出一串hash值，我们把它称之为“SQL_ID"
2、将存储引擎返回上来的表的内容+SQLID存储到查询缓存中

使用方式：
1、一条SQL执行时，进行hash运算，得出SQLID，去找query cache
2、如果cache中有，则直接返回数据行，如果没有，就走原有的SQL执行流程

一个sql查询如果以select开头，那么mysql服务器将尝试对其使用查询缓存。
注：两个sql语句，只要想差哪怕是一个字符（列如大小写不一样；多一个空格等）,那么这两个sql将使用不同的一个cache。

（2）判断依据
mysql> show status like "%Qcache%";
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| Qcache_free_blocks      | 1       |
| Qcache_free_memory      | 1031360 |
| Qcache_hits             | 0       |
| Qcache_inserts          | 0       |
| Qcache_lowmem_prunes    | 0       |
| Qcache_not_cached       | 2002    |
| Qcache_queries_in_cache | 0       |
| Qcache_total_blocks     | 1       |
+-------------------------+---------+
8 rows in set (0.00 sec)

---------------------状态说明--------------------
Qcache_free_blocks：缓存中相邻内存块的个数。
如果该值显示较大，则说明Query Cache 中的内存碎片较多了，FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。
注：当一个表被更新之后，和它相关的cache blocks将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。可以用FLUSH QUERY CACHE语句来清空free blocks

Qcache_free_memory：Query Cache 中目前剩余的内存大小。通过这个参数我们可以较为准确的观察出当前系统中的Query Cache 内存大小是否足够，是需要增加还是过多了。

Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。

Qcache_inserts：表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。

Qcache_lowmem_prunes：
多少条Query因为内存不足而被清除出QueryCache。通过“Qcache_lowmem_prunes”和“Qcache_free_memory”相互结合，能够更清楚的了解到我们系统中Query Cache 的内存大小是否真的足够，是否非常频繁的出现因为内存不足而有Query 被换出。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。（上面的free_blocks和free_memory可以告诉您属于哪种情况）

Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。

Qcache_queries_in_cache：当前Query Cache 中cache 的Query 数量；
Qcache_total_blocks：当前Query Cache 中的block 数量；。
Qcache_hits / (Qcache_inserts+Qcache_not_cached+Qcache_hits) 
    90/         10000             0             90

如果出现hits比例过低，其实就可以关闭查询缓存了。使用redis专门缓存数据库

Qcache_free_blocks    来判断碎片
Qcache_free_memory   +   Qcache_lowmem_prunes  来判断内存够不够
Qcache_hits 多少次命中  Qcache_hits / (Qcache_inserts+Qcache_not_cached+Qcache_hits)  

（3）配置示例
mysql> show variables like '%query_cache%' ;
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| have_query_cache             | YES     |
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 1048576 |
| query_cache_type             | OFF     |
| query_cache_wlock_invalidate | OFF     |
+------------------------------+---------+
6 rows in set (0.00 sec)

mysql> 
-------------------配置说明-------------------------------
以上信息可以看出query_cache_type为off表示不缓存任何查询

各字段的解释：
query_cache_limit：超过此大小的查询将不缓存
query_cache_min_res_unit：缓存块的最小大小，query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。
query_cache_size：查询缓存大小 (注：QC存储的最小单位是1024byte，所以如果你设定了一个不是1024的倍数的值，这个值会被四舍五入到最接近当前值的等于1024的倍数的值。)

query_cache_type：缓存类型，决定缓存什么样的查询，注意这个值不能随便设置，必须设置为数字，可选项目以及说明如下：
如果设置为0，那么可以说，你的缓存根本就没有用，相当于禁用了。
如果设置为1，将会缓存所有的结果，除非你的select语句使用SQL_NO_CACHE禁用了查询缓存。
如果设置为2，则只缓存在select语句中通过SQL_CACHE指定需要缓存的查询。

修改/etc/my.cnf,配置完后的部分文件如下：
query_cache_size=128M
query_cache_type=1
```

最大错误连接次数

```undefined
max_connect_errors是一个mysql中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码等情况，当超过指定次数，mysql服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hosts命令清空此host的相关信息 max_connect_errors的值与性能并无太大关系。

vim /etc/my.cnf
[mysqld]
max_connect_errors=2000
```

最大允许传输包的大小⭐

```undefined
（1）简介：
mysql根据配置文件会限制，server接受的数据包大小。
（2）配置依据：
有时候大的插入和更新会受max_allowed_packet参数限制，导致写入或者更新失败，更大值是1GB，必须设置1024的倍数
（3）配置方法：
max_allowed_packet=256M
```

服务器线程缓存

```ruby
(1)简介
服务器线程缓存，这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时,那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁(前提是缓存数未达上限),如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.
（2）配置依据
通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。
设置规则如下（实际会设置少一些）：1GB 内存配置为8，2GB配置为16，3GB配置为32，4GB或更高内存，可配置更大。
服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)

试图连接到MySQL(不管是否连接成功)的连接数
mysql>  show status like 'threads_%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_cached    | 8     |
| Threads_connected | 2     |
| Threads_created   | 4783  |
| Threads_running   | 1     |
+-------------------+-------+
4 rows in set (0.00 sec)

Threads_cached :代表当前此时此刻线程缓存中有多少空闲线程。
Threads_connected:代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。
Threads_created:代表从最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗cpu SYS资源，可以适当增加配置文件中thread_cache_size值。
Threads_running :代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。
(3)配置方法：
thread_cache_size=32
```

innodb_buffer_pool_size⭐

```undefined
（1）简介
对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。
（2）配置依据：
InnoDB使用该参数指定大小的内存来缓冲数据和索引。
对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%,一般我们建议不要超过物理内存的70%。
（3）配置方法
innodb_buffer_pool_size=2048M
```

innodb_flush_log_at_trx_commit⭐

```bash
（1）简介
主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。
0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；
1，每次事务的提交都会引起redo日志文件写入、flush磁盘的操作，确保了事务的ACID；
2，每次事务提交引起写入日志文件的动作,但每秒钟完成一次flush磁盘操作。

（2）配置依据
实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。
根据MySQL官方文档，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。
（3）配置方法
innodb_flush_log_at_trx_commit=1
双1标准中的一个1
```

innodb_thread_concurrency

```dart
（1）简介
此参数用来设置innodb线程的并发数量，默认值为0表示不限制。
（2）配置依据
在官方doc上，对于innodb_thread_concurrency的使用，也给出了一些建议，如下：
如果一个工作负载中，并发用户线程的数量小于64，建议设置innodb_thread_concurrency=0；
如果工作负载一直较为严重甚至偶尔达到顶峰，建议先设置innodb_thread_concurrency=128，
并通过不断的降低这个参数，96, 80, 64等等，直到发现能够提供最佳性能的线程数，
例如，假设系统通常有40到50个用户，但定期的数量增加至60，70，甚至200。你会发现，
性能在80个并发用户设置时表现稳定，如果高于这个数，性能反而下降。在这种情况下，
建议设置innodb_thread_concurrency参数为80，以避免影响性能。
如果你不希望InnoDB使用的虚拟CPU数量比用户线程使用的虚拟CPU更多（比如20个虚拟CPU），
建议通过设置innodb_thread_concurrency 参数为这个值（也可能更低，这取决于性能体现），
如果你的目标是将MySQL与其他应用隔离，你可以l考虑绑定mysqld进程到专有的虚拟CPU。
但是需 要注意的是，这种绑定，在myslqd进程一直不是很忙的情况下，可能会导致非最优的硬件使用率。在这种情况下，
你可能会设置mysqld进程绑定的虚拟 CPU，允许其他应用程序使用虚拟CPU的一部分或全部。
在某些情况下，最佳的innodb_thread_concurrency参数设置可以比虚拟CPU的数量小。
定期检测和分析系统，负载量、用户数或者工作环境的改变可能都需要对innodb_thread_concurrency参数的设置进行调整。

128   -----> top  cpu  
设置标准：
1、当前系统cpu使用情况，均不均匀
top

2、当前的连接数，有没有达到顶峰
show status like 'threads_%';
show processlist;
（3）配置方法：
innodb_thread_concurrency=8
方法:
    1. 看top ,观察每个cpu的各自的负载情况
    2. 发现不平均,先设置参数为cpu个数,然后不断增加(一倍)这个数值
    3. 一直观察top状态,直到达到比较均匀时,说明已经到位了.
```

innodb_log_file_size⭐

```undefined
设置 ib_logfile0  ib_logfile1 
此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能.
innodb_log_file_size = 100M
```

innodb_log_files_in_group⭐

```undefined
为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3
```

binary log

```kotlin
log-bin=/data/mysql-bin
binlog_cache_size = 2M //为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存, 提高记录bin-log的效率。没有什么大事务，dml也不是很频繁的情况下可以设置小一点，如果事务大而且多，dml操作也频繁，则可以适当的调大一点。前者建议是--1M，后者建议是：即 2--4M
max_binlog_cache_size = 8M //表示的是binlog 能够使用的最大cache 内存大小
max_binlog_size= 512M //指定binlog日志文件的大小，如果当前的日志大小达到max_binlog_size，还会自动创建新的二进制日志。你不能将该变量设置为大于1GB或小于4096字节。默认值是1GB。在导入大容量的sql文件时，建议关闭sql_log_bin，否则硬盘扛不住，而且建议定期做删除。
expire_logs_days = 7 //定义了mysql清除过期日志的时间。
二进制日志自动删除的天数。默认值为0,表示“没有自动删除”。
log-bin=/data/mysql-bin
binlog_format=row 
sync_binlog=1
双1标准(基于安全的控制)：
sync_binlog=1   什么时候刷新binlog到磁盘，每次事务commit
innodb_flush_log_at_trx_commit=1
set sql_log_bin=0;
show status like 'com_%';
```

安全参数

```ruby
Innodb_flush_method=(O_DIRECT, fsync) 
1、fsync    ：
（1）在数据页需要持久化时，首先将数据写入OS buffer中，然后由os决定什么时候写入磁盘
（2）在redo buffuer需要持久化时，首先将数据写入OS buffer中，然后由os决定什么时候写入磁盘
但，如果innodb_flush_log_at_trx_commit=1的话，日志还是直接每次commit直接写入磁盘
2、 Innodb_flush_method=O_DIRECT
（1）在数据页需要持久化时，直接写入磁盘
（2）在redo buffuer需要持久化时，首先将数据写入OS buffer中，然后由os决定什么时候写入磁盘
但，如果innodb_flush_log_at_trx_commit=1的话，日志还是直接每次commit直接写入磁盘

最安全模式：
innodb_flush_log_at_trx_commit=1
innodb_flush_method=O_DIRECT
最高性能模式：
innodb_flush_log_at_trx_commit=0
innodb_flush_method=fsync
        
一般情况下，我们更偏向于安全。 
“双一标准”
innodb_flush_log_at_trx_commit=1        ***************
sync_binlog=1                                   ***************
innodb_flush_method=O_DIRECT
```

## 系统优化

**调整swap**

```bash
echo 0 >/proc/sys/vm/swappiness的内容改成0（临时），默认30，即内存剩余30%就启用swap

/etc/sysctl.conf上添加vm.swappiness=0（永久）
sysctl -p

这个参数决定了Linux是倾向于使用swap，还是倾向于释放文件系统cache。在内存紧张的情况下，数值越低越倾向于释放文件系统cache。
当然，这个参数只能减少使用swap的概率，并不能避免Linux使用swap。

修改MySQL的配置参数innodb_flush_method，开启O_DIRECT模式
这种情况下，InnoDB的buffer pool会直接绕过文件系统cache来访问磁盘，但是redo log依旧会使用文件系统cache。值得注意的是，Redo log是覆写模式的，即使使用了文件系统的cache，也不会占用太多
```

**内核配置优化**

```text
#TIME_WAIT超时时间，默认是60s
net.ipv4.tcp_fin_timeout = 30
#1表示开启复用，允许TIME_WAIT socket重新用于新的TCP连接，0表示关闭
net.ipv4.tcp_tw_reuse = 1
#1表示开启TIME_WAIT socket快速回收，0表示关闭
net.ipv4.tcp_tw_recycle = 1
#系统保持TIME_WAIT socket最大数量，如果超出这个数，系统将随机清除一些TIME_WAIT并打印警告信息
net.ipv4.tcp_max_tw_buckets = 4096
#进入SYN队列最大长度，加大队列长度可容纳更多的等待连接
net.ipv4.tcp_max_syn_backlog = 4096
```

**打开文件句柄优化**

```text
vi /etc/security/limits.conf
* soft nofile 65535
* hard nofile 65535
```

不要使用lvm

使用ext4或xfs

## 主从优化

```go
## 5.7 从库多线程MTS
基本要求:
5.7以上的版本(忘记小版本)
必须开启GTID 
binlog必须是row模式  

gtid_mode=ON
enforce_gtid_consistency=ON
log_slave_updates=ON
slave-parallel-type=LOGICAL_CLOCK
slave-parallel-workers=16
master_info_repository=TABLE
relay_log_info_repository=TABLE
relay_log_recovery=ON

5.7 :
slave-parallel-type=LOGICAL_CLOCK
slave-parallel-workers=8
cpu核心数作为标准

CHANGE MASTER TO
  MASTER_HOST='10.0.0.128',
  MASTER_USER='repl',
  MASTER_PASSWORD='123',
  MASTER_PORT=3307,
  MASTER_AUTO_POSITION=1;
start slave;
```

## 数据库安全优化

数据库安全是项目中最重要的部分，信息泄露会造成重大事故，所以要重视安全问题，防止信息被盗取、破坏。

**具体建议**

1. 数据库使用 **mysql 用户启动，权限为700**

   ```shell
   [mysql.server]
   user=mysql
   ```

2. 登录时在命令行暴漏密码，备份脚本中如果有密码，给设置 700，属主和用户组为 mysql或root

3. 初始**删除无用的用户**，只保留 root 127.0.0.1 和 root localhost

4. 授权用户对应的主机不要用%，权限不要给 all，**最小化授权**，从库只给select 权限

5. 删除默认存在的 test 库

6. 为mysq用户设置复杂密码

7. 不要给一个用户管所有的库，尽量**专库专用户**

8. 清理 mysql 操作日志文件~/mysql_history

9. 禁止开发获取到 web 连接的密码，禁止开发连接操作生产对外的库

10. 服务器**禁止设置外网IP**

11. 防 SQL 注入（WEB）， php.ini 配置文件里面设置

## 数据维护

### 性能状态关键指标

通常使用QPS（Queries Per Second，每秒查询数）和TPS（Transactions Per Second，每秒事务处理量）来查看数据库的效率。

通过show status查看运行状态，会有300多条状态信息记录，其中有几个值可以计算出QPS和TPS，如下：
Uptime：服务器已经运行的实际，单位秒
Questions：已经发送给数据库查询数
Com_select：查询次数，实际操作数据库的
Com_insert：插入次数
Com_delete：删除次数
Com_update：更新次数
Com_commit：事务次数
Com_rollback：回滚次数

基于Questions计算出QPS
mysql> `show global status like 'Questions';`
mysql> `show global status like 'Uptime';`
QPS = Questions / Uptime

基于Com_commit和Com_rollback计算出TPS：
mysql> `show global status like 'Com_commit';`
mysql> `show global status like 'Com_rollback';`
mysql> `show global status like 'Uptime';`
TPS = (Com_commit + Com_rollback) / Uptime

### MySQL性能分析

**重点关注：**
id：**CPU利用率百分比**，平均小于60%正常，但已经比较繁忙了。
wa：**CPU等待磁盘IO响应时间**，一般大于5说明磁盘读写量大。

![file](https://gitee.com/c_honghui/picture/raw/master/img/20210217233701.png)

KB_read/s、KB_wrtn/s **每秒读写数据量**，主要根据磁盘每秒**最高**读写速度评估。

![file](https://gitee.com/c_honghui/picture/raw/master/img/20210217233706.png)

r/s、w/s：**每秒读写请求次数**，可以理解为IOPS（每秒输入输出量），是衡量磁盘性能的主要指标之一。
await：**IO平均每秒响应时间**，一般大于5说明磁盘响应慢，超过自身性能。
util：**磁盘利用率百分比**，平均小于60%正常，但已经比较繁忙了。

![file](https://gitee.com/c_honghui/picture/raw/master/img/20210217233711.png)



使用explain可以模拟查询优化器执行sql查询语句，从而知道mysql是如何处理你的sql语句的。即查看某个查询语句的执行计划。

使用方法：

```mysql
Explain + SQL语句
```

各字段解释：

**（1）id**

select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序

id相同，执行顺序由上至下

id不同，如果是子查询，id值越大优先级越高，越先被执行

**（2）select_type**

SIMPLE
释义：简单的 select 查询,查询中不包含子查询或者UNION

PRIMARY
释义：查询中若包含任何复杂的子部分，最外层查询则被标记为Primary

DERIVED
释义：在FROM某个表中包含的子查询被标记为DERIVED(衍生) ，MySQL会递归执行这些子查询, 把结果放在临时表里。

SUBQUERY
释义：在SELECT或WHERE列表中包含了子查询

UNION
释义：若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED

UNION RESULT
释义：从UNION表获取结果的SELECT

**（3）table**

显示这一行的数据是关于哪张表的

**（4）type**

type显示的是访问类型，是较为重要的一个指标，其值从最好到最坏依次是 ：  

```text
system>const>eq_ref>ref>range（尽量保证）>index>ALL   
```

一般来说，得保证查询至少达到range级别，最好能达到ref。 

system
释义：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计

const
释义：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快 如将主键置于where列表中，MySQL就能将该查询转换为一个常量
eq_ref
释义：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描

ref
释义：非唯一性索引扫描，返回匹配某个单独值的所有行. 本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而， 它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体

range
释义：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引 一般就是在你的where语句中出现了between、<、>、in等的查询 这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。

index
释义：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。 （也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）

all
释义：Full Table Scan，将遍历全表以找到匹配的行，没有索引

**（5）possible-keys**

显示该查询可能会用到的索引。 查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

**（6）key**

实际使用的索引。如果为NULL，则没有使用索引。

**（7）key_len**

表示索引中使用的字节数，在不损失精确度的情况下，长度越短越好

**（8）ref**

显示索引的哪一列被使用了

**（9）rows**

rows列显示MySQL认为它执行查询时必须检查的行数。越少越好

**（10）Extra**

Extra（额外的），其中包含不适合在其他列中显示但十分重要的额外信息。

Using filesort
释义：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。 MySQL中无法利用索引完成的排序操作称为“文件排序”

Using temporary
释义：使用了临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。

Using join buffer
释义：使用了连接缓存
当你使用左连接、右连接、内连接、或者联表查询时都有可能出现出现！

Using index
表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！ 如果同时出现using where，表明索引被用来执行索引键值的查找; 如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。

Using where
表明使用了where过滤

impossible where
where子句的值总是false，不能用来获取任何元组