# 主从复制

应用场景:

数据备份和容灾 读写分离 业务拆分

```css
1.1. 基于二进制日志复制的
1.2. 主库的修改操作会记录二进制日志
1.3. 从库会请求新的二进制日志并回放,最终达到主从数据同步
1.4. 主从复制核心功能:
辅助备份,处理物理损坏                   
扩展新型的架构:高可用,高性能,分布式架构等
```

前提

```shell
## 2.1 两台以上mysql实例 ,server_id,server_uuid不同
## 2.2 主库开启二进制日志
## 2.3 专用的复制用户
## 2.4 保证主从开启之前的某个时间点,从库数据是和主库一致(补课)
## 2.5 告知从库,复制user,passwd,IP port,以及复制起点(change master to)
## 2.6 线程(三个):Dump thread  IO thread  SQL thread 开启(start slave)
```

数据库复制本质上就是数据同步。MySQL 数据库是基于二进制日志（binary log）进行数据增量同步，而二进制日志记录了所有对于 MySQL 数据库的修改操作。

在默认 ROW 格式二进制日志中，一条 SQL 操作影响的记录会被全部记录下来，比如一条 SQL语句更新了三行记录，在二进制日志中会记录被修改的这三条记录的前项（before image）和后项（after image）。

## 原理

![img](https://gitee.com/c_honghui/picture/raw/master/img/20210217233458.png)

```text
1.change master to 时，ip pot user password binlog position写入到master.info进行记录
2. start slave 时，从库会启动IO线程和SQL线程
3.IO_T，读取master.info信息，获取主库信息连接主库
4. 主库会生成一个准备binlog DUMP线程，来响应从库
5. IO_T根据master.info记录的binlog文件名和position号，请求主库DUMP最新日志
6. DUMP线程检查主库的binlog日志，如果有新的，TP(传送)给从从库的IO_T
7. IO_T将收到的日志存储到了TCP/IP 缓存，立即返回ACK给主库 ，主库工作完成
8.IO_T将缓存中的数据，存储到relay-log日志文件,更新master.info文件binlog 文件名和postion，IO_T工作完成
9.SQL_T读取relay-log.info文件，获取到上次执行到的relay-log的位置，作为起点，回放relay-log
10.SQL_T回放完成之后，会更新relay-log.info文件。
11. relay-log会有自动清理的功能。
细节：
1.主库一旦有新的日志生成，会发送“信号”给binlog dump ，IO线程再请求
```

## 主从复制方式

mysql主从复制有异步复制、半同步复制、GTID复制等。

### 异步复制

默认复制模式，主库将数据写到binlog就直接返回给客户端更新成功，**不用关心 Slave 是否接收到二进制日志**

有点风险（如果还没来得及同步到从库就会丢失数据），但性能好（从库复制不会影响到主库写数据）

如果业务对于数据一致性要求不高，当发生故障时，能容忍数据的丢失，甚至大量的丢失，推荐用异步复制，这样性能最好

### 半同步复制

同步复制：主库执行完客户端提交的事务后，需要等所有从库都执行完这一事务后才返回给客户端执行成功。性能有所影响。

半同步复制：介于异步和同步之间，主库执行完客户端提交的事务后要等待**至少一个从库接收到binlog并写入到relaylog中**才返回给客户端执行成功。

半同步，在主库的dump线程增加了一个ack机制，不但要发送binlog，还要接收从库的ack，当出现异常将自动降级为异步复制，直到修复后变成半同步。

风险：

客户端提交事务后，主库在等待从库ack时宕机了，会有两种情况：

- 事务还没发生到从库：客户端收到失败后会重新提交事务，重新提交是在新的主库执行，所以会执行成功，如果之前的主库恢复了，会以从库身份加入集群，这时候之前的事务会被执行两次：第一次是此机器作为主库时执行，第二次是作为从库后从主库同步过来

- 事务已经同步到从库：客户端收到失败后重新提交，事务会在从库执行两次

解决：

5.7版本开始增加新的半同步方式（5.7.2默认）：从库的事务ack后，才提交主库事务

依然有风险：如果主库等待从库同步成功的过程主库就挂了，主库事务就提交失败，但从库已经把binlog写入relaylog，这时从库数据就多了，但多了一半不严重。

半同步复制模式参数：

```mysql
show variables like '%Rpl%';
```

### GTID复制

5.6开始推出GTID模式（全局事务ID）

GTID由server_uuid（实例唯一标识）和transactionld（该mysql执行事务的数量）组成

```mysql
show master status;
```

原理：

```text
从库把自己执行过的GTID和获取的GTID都传给主库，主库发送缺少的GTID给从库，让从库补全数据。当主库挂了，会把同步最成功的从库提升为主库。

master更新数据时，在事务前生产GTID，一同记录到binlog
slave把变更的binlog写入relaylog
sql线程从relaylog获取GTID，然后对比slave的binlog是否有记录
如果有记录说明该GTID事务已经执行，slave会忽略
如果没有记录，slave从relaylog执行该GTID事务，并记录到binlog
```

优缺点：



配置：



## 主从复制搭建

步骤：

```text
1.创建复制所需要的账号和权限
2.从master拷贝一份数据
3.通过命令change master to搭建复制关系
4.通过命令show slave status观察复制状态
```

务必在配置文件中设置：

```shell
gtid_mode = on
enforce_gtid_consistency = 1
binlog_gtid_simple_recovery = 1
relay_log_recovery = ON
master_info_repository = TABLE 
relay_log_info_repository = TABLE
```

上述设置都是用于保证 crash safe，即无论 Master 还是 Slave 宕机，当它们恢复后，连上主机后，主从数据依然一致，不会产生任何不一致的问题。

### 一.准备

1.主从数据库版本最好一致
2.主从数据库内数据保持一致，若不一致，可将从库中所有数据删除，并将主库全部数据导入进去

主数据库：182.92.172.80
从数据库：123.57.44.85

### 二.操作

#### 主数据库操作

1.开启binlog

```
[mysqld]log-bin=mysql-bin #开启二进制日志server-id=1 #设置server-id，和从不能一样
```

2.重启mysql，创建用于同步的用户账号
`systemc restart mysql`

登陆数据库
`mysql -hlocalhost -uname -ppassword`

创建用户并授权：用户：test密码：123456，ip修改为从的ip
`CREATE USER 'test'@'123.57.44.85' IDENTIFIED BY '123456';`

分配中权限
`GRANT REPLICATION SLAVE ON *.* TO 'test'@'123.57.44.85';`
`flush privileges;`

锁表，禁止写入，当前窗口不能退出，这时候开启另一个终端继续操作
`flush table with read lock;`

3.新窗口操作，查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：

```
SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       |       |     |+------------------+----------+--------------+------------------+
```

4.将当前数据导出
`mysqldump -u root -p --all-databases > /root/alldb.sql`

5.解锁查看binlog日志位置，如果没变证明锁定成功。从库将从这个binlog日志开始恢复
`unlock table;`

```
SHOW MASTER STATUS;+------------------+----------+--------------+------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000003 | 73       |       |     |+------------------+----------+--------------+------------------+
```

#### 从服务器操作

1.导入数据
`mysql -uroot -p < alldb.sql`

2.修改配置文件
`vim /etc/my.cnf`

```
[mysqld]server-id=2 #设置server-id，必须唯一
```

3.重启mysql，配置同步
需要主服务器主机名，登陆凭据，二进制文件的名称和位置
`CHANGE MASTER TO MASTER_HOST='182.92.172.80', MASTER_USER='test', MASTER_PASSWORD='123456', MASTER_LOG_FILE='mysql-bin.000003', MASTER_LOG_POS=73;`
`start slave;`

4.查看slave状态：
`show slave status\G;`

```
*************************** 1. row ***************************               Slave_IO_State: Waiting for master to send event                  Master_Host: 182.92.172.80                  Master_User: rep1                  Master_Port: 3306                Connect_Retry: 60              Master_Log_File: mysql-bin.000013          Read_Master_Log_Pos: 11662               Relay_Log_File: mysqld-relay-bin.000022                Relay_Log_Pos: 11765        Relay_Master_Log_File: mysql-bin.000013             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:           Replicate_Ignore_DB:         ...
```

Slave_IO_Running: Yes
Slave_SQL_Running: Yes
都是yes即可

## 主从故障监控\分析\处理 

### 线程相关监控

主库：

```mysql
show full processlist;
每个从库都会有一行dump相关的信息
HOSTS: 
db01:47176
State:
Master has sent all binlog to slave; waiting for more updates
如果现实非以上信息,说明主从之间的关系出现了问题   
```

从库：

```mysql
db01 [(none)]>show slave status \G
*************************** 1. row ***************************
主库相关信息监控
Master_Host: 10.0.0.51
Master_User: repl
Master_Port: 3307
Master_Log_File: mysql-bin.000005
Read_Master_Log_Pos: 444

从库中继日志的应用状态
Relay_Log_File: db01-relay-bin.000002
Relay_Log_Pos: 485

从库复制线程有关的状态
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Last_IO_Errno: 0
Last_IO_Error: 
Last_SQL_Errno: 0
Last_SQL_Error: 

过滤复制有关的状态
Replicate_Do_DB: 
Replicate_Ignore_DB: 
Replicate_Do_Table: 
Replicate_Ignore_Table: 
Replicate_Wild_Do_Table: 
Replicate_Wild_Ignore_Table: 

主从延时相关状态(非人为)
Seconds_Behind_Master: 0

延时从库有关的状态(人为)
SQL_Delay: 0
SQL_Remaining_Delay: NULL

GTID 复制有关的状态
Retrieved_Gtid_Set: 
Executed_Gtid_Set: 
Auto_Position: 0
```

### 主从复制故障分析

主库连接数上限,或者是主库太繁忙

```mysql
show slave staus \G 
Last_IO_Errno: 1040
Last_IO_Error: error reconnecting to master 'repl@10.0.0.51:3307' - retry-time: 10  retries: 7
处理思路:
拿复制用户,手工连接一下

[root@db01 ~]# mysql -urepl -p123 -h 10.0.0.51 -P 3307 
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 1040 (HY000): Too many connections
处理方法:
db01 [(none)]>set global max_connections=300;

(3) 防火墙,网络不通
```

二进制日志

```csharp
主库缺失日志
从库方面,二进制日志位置点不对
Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: 'could not find next log; the first event 'mysql-bin.000001' at 154, the last event read from '/data/3307/data/mysql-bin.000002' at 154, the last byte read from '/data/3307/data/mysql-bin.000002' at 154.'
    
注意: 在主从复制环境中,严令禁止主库中reset master; 可以选择expire 进行定期清理主库二进制日志
解决方案:
重新构建主从
```

### MySQL 主从同步延时问题

```undefined
主库做了修改操作,从库比较长时间才能追上.
```

外在因素:

```undefined
网络 
主从硬件差异较大
版本差异
参数因素
```

主库:

```css
(1) 二进制日志写入不及时
[rep]>select @@sync_binlog;
(2) CR的主从复制中,binlog_dump线程,事件为单元,串行传送二进制日志(5.6 5.5)

1. 主库并发事务量大,主库可以并行,传送时是串行
2. 主库发生了大事务,由于是串行传送,会产生阻塞后续的事务.

解决方案:
1. 5.6 开始,开启GTID,实现了GC(group commit)机制,可以并行传输日志给从库IO
2. 5.7 开始,不开启GTID,会自动维护匿名的GTID,也能实现GC,我们建议还是认为开启GTID
3. 大事务拆成多个小事务,可以有效的减少主从延时.
```

从库:

```css
SQL线程导致的主从延时
在CR复制情况下: 从库默认情况下只有一个SQL,只能串行回放事务SQL
1. 主库如果并发事务量较大,从库只能串行回放
2. 主库发生了大事务,会阻塞后续的所有的事务的运行

解决方案:
1. 5.6 版本开启GTID之后,加入了SQL多线程的特性,但是只能针对不同库(database)下的事务进行并发回放.
2. 5.7 版本开始GTID之后,在SQL方面,提供了基于逻辑时钟(logical_clock),binlog加入了seq_no机制,
真正实现了基于事务级别的并发回放,这种技术我们把它称之为MTS(enhanced multi-threaded slave).
3. 大事务拆成多个小事务,可以有效的减少主从延时.
[https://dev.mysql.com/worklog/task/?id=6314]
```

我们通过 MySQL 命令：

```mysql
show slave status
```

查看 `Seconds_Behind_Master` ，可以看到从库复制主库的数据落后了几 ms。

一般来说，如果主从延迟较为严重，有以下解决方案：

- **分库**，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。
- 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。
- **重写代码**，写代码的同学，要慎重，插入数据时立马查询可能查不到。
- 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询**设置直连主库**。**不推荐**这种方法，你要是这么搞，读写分离的意义就丧失了。