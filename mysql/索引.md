# 索引

## 介绍

一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是**最容易出问题的，还是一些复杂的查询操作**。

因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。

索引在MySQL中也叫做“键”，是**存储引擎用于快速找到记录的一种数据结构**。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。

索引优化应该是对**查询性能优化最有效的手段**了。索引能够轻易将查询性能提高好几个数量级。索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。

## 索引的数据结构

B+Tree:

![file](https://gitee.com/c_honghui/picture/raw/master/img/20210217233527.png)

浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3。P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。**真实的数据存在于叶子节点**即3、5、9、10、13、15、28、29、36、60、75、79、90、99。**非叶子节点不存储真实的数据，只存储指引搜索方向的数据项**，如17、35并不真实存在于数据表中。

b+树的查找过程:

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

## 索引管理

### 索引分类

1.普通索引index :加速查找
2.唯一索引
    主键索引：primary key ：加速查找+约束（不为空且唯一）
    唯一索引：unique：加速查找+约束 （唯一）
3.联合索引
    -primary key(id,name):联合主键索引
    -unique(id,name):联合唯一索引
    -index(id,name):联合普通索引
4.全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。
5.空间索引spatial :了解就好，几乎不用



不同的存储引擎支持的索引类型也不一样

- InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
- MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；

### 索引应用场景

假如一个系统有个会员表，有以下字段：

会员编号 INT
会员姓名 VARCHAR(10)
会员身份证号码 VARCHAR(18)
会员电话 VARCHAR(10)
会员住址 VARCHAR(50)
会员备注信息 TEXT

那么这个 会员编号，作为主键，使用 PRIMARY
会员姓名 如果要建索引的话，那么就是普通的 INDEX
会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）

## 操作索引

在创建表时创建索引：

``` mysql
create table s1（
id int,
name char(20),
age int,
email varchar(30),
primary key(id),
#index(id),
）;
```

创建表后添加索引：

`create index name on s1(name);` #添加普通索引
`create unique index age on s1(age);` 添加唯一索引
`alter table s1 add primary key(id);` #添加主键索引，也就是给id字段增加一个主键约束
`create index name on s1(id,name);` #添加普通联合索引

查看索引：

`mysql> show index from stu;` 查看sut表的索引

删除索引：

`drop index name on s1;` #删除普通索引
`drop index age on s1;` #删除唯一索引，就和普通索引一样，不用在index前加unique来删，直接就可以删了
`alter table s1 drop primary key;` #删除主键(因为它添加的时候是按照alter来增加的，那么我们也用alter来删)

避免：

1. `- 避免使用select *`
2. `- count(1)或count(列) 代替 count(*)`
3. `- 创建表时尽量时 char 代替 varchar`
4. `- 表的字段顺序固定长度的字段优先`
5. `- 组合索引代替多个单列索引（经常使用多个条件查询时）`
6. `- 尽量使用短索引`
7. `- 使用连接（JOIN）来代替子查询(Sub-Queries)`
8. `- 连表时注意条件类型需一致`
9. `- 索引散列值（重复少）不适合建索引，例：性别不适合`