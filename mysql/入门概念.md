# 入门概念

## 数据库管理系统种类

### 关系型数据库(RDBMS)

简单来说，关系模式就是二维表格模型

主要代表：SQL server、mysql、oracle

如下表，可以根据love=画画找到喜欢画画的人

| name | age  | love |
| :--: | :--: | :--: |
|  A   |  11  | 画画 |

 优点：二维表格容易理解；通用的sql语句使用方便；易于维护，数据库的[ACID属性](http://www.52wiki.cn/docs/pu/472)，大大降低了数据冗余和数据不一致的概率

缺点：高并发对硬盘IO是个挑战；难以横向扩展

### 非关系型数据库

指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，主要代表MongoDB，Redis、CouchDB。已key-value来存储值。

优点：数据放在内存，读取快；扩展方便，数据间没有关系

缺点：不支持sql，不支持事务

## 基本架构

mysql可以分为server层和存储引擎层

**server层**包括连接器、查询缓冲、分析器、优化器、执行器

**存储引擎层**负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。



### 一条sql查询语句如何执行

**连接器**

第一步，你会先连接到这个数据库上。连接器负责跟客户端**建立连接、获取权限、维持和管理连接**

```shell
mysql -h$ip -P$port -u$user -p
```



连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它，command列会显示sleep。

**客户端如果太长时间没动静，连接器就会自动将它断开**。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。

数据库里面，**长连接**是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。**短连接**则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。



**查询缓冲**

`MySQL`中**数据是以页为单位**，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫**数据页，会放入到`Buffer Pool`中。**

**后续的查询都是先从`Buffer Pool`中找，没有命中再去硬盘加载，减少硬盘`IO`开销，提升性能。**

如果语句不在查询缓冲池中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓冲池中。

如果查询命中缓冲，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高



但是查询缓冲的失效非常频繁，**只要有对一个表的更新，这个表上所有的查询缓冲都会被清空**。

好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓冲。而对于你确定要使用查询缓冲的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

```shell
mysql> select SQL_CACHE * from T where ID=10；
```

需要注意的是，**MySQL 8.0 版本直接将查询缓冲的整块功能删掉了**，也就是说 8.0 开始彻底没有这个功能了。



**分析器**

没有命中缓存，就开始执行语句，执行语句之前MySQL 需要知道**你要做什么**

分析器先会做**“词法分析”**。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。

做完了这些识别以后，就要做**“语法分析”**。语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒



**优化器**

经过分析器mysql知道你要做什么后，**要决定怎么做**；优化器是在表里有多个索引的时候决定使用哪个索引，或者一个语句有多表关联（join）的时候决定各个表的连接顺序

优化器阶段完成后，这个语句的**执行方案就确定下来**了，然后进入执行器阶段



**执行器**

进入了执行器阶段，开始执行语句。

以这个语句为例：

```mysql
mysql> select * from T where ID=10;
```

执行器的执行流程是这样的：

调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；

调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。

执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。



### 一条sql更新语句如何执行

执行器和 InnoDB 引擎在执行`update T set c=c+1 where ID=2;`这个简单的 update 语句时的内部流程：

执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的**数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。**

执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再**调用引擎接口写入**这行新数据。

引擎将这行新数据更新到内存中，同时**将这个更新操作记录到 redo log** 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

执行器**生成这个操作的 binlog**，并把 binlog 写入磁盘。

执行器**调用引擎的提交事务接口**，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

## 事务

事务是作为单个逻辑单元执行的一系列的操作，这些操作作为一个整体向系统提交，要么执行，要么都不执行

开启一个事务可以包含一些sql语句，这些sql语句要么同时成功 要么一个都别想成功，称之为事务的原子性

### ACID特性

**Atomic（原子性）**

```undefined
所有语句作为一个单元全部成功执行或全部取消。不能出现中间状态。
```

**Consistent（一致性）**

```undefined
如果数据库在事务开始时处于一致状态，则在执行该事务期间将保留一致状态。
```

**Isolated（隔离性）**

```undefined
事务之间不相互影响。
```

**Durable（持久性）**

```undefined
事务成功完成后，所做的所有更改都会准确地记录在数据库中。所做的更改不会丢失。
```

### 模拟

说到事务，很容易想到就是那个经典的银行转账问题。假如资金从A账户转到B账户，至少需要两步，第一步，账户A的资金减少第二部，账户B的资金增加。

添加check约束，当前余额要大于1元。

``` mysql
ALTER TABLE bank
   ADD CONSTRAINT CK_Money
       CHECK(money>=1)
```

现在一共是3201元，张三200元，李四1201元，接下来执行转账操作

``` mysql
update bank set money=money-200 where name='张三';
update bank set money=money+200 where name='李四';
```

同时执行会报错，张三的金额没少，但李四却多了200

错误原因是：张三的账户减少200后，现在余额变成了0元，update语句违反约束：余额>=0元，所以会执行失败，此时报错，张三的金额不会减少。接着执行第二个update语句，第二句执行成功，所以李四增加200元，变成1401元。

转账过程就是一个事务，转账需要两条update 语句，这两条语句是一个整体，如果其中一条出现错误，那么整个转账的业务也会取消，两个账户的余额应该恢复到原来的数据，从而确保转账前和转账后的余额不变。

常用的事务语句：开始事务：begin transaction ;提交事务：commit transaction ;回滚事务：rollback transaction .一旦事务提交或者回滚，那么事务结束。使用全局变量@@ERROR，@@ERROR只能够判断当前的sql语句是否执行有错，为了判断事务中所有的sql语句是否有错，我们需要对错误累计。set @ErrorSum=@ErrorSum+@@error.

## 数据切分方法

### 概念

通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。

数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式：垂直（纵向）切分和水平（横向）切分

### 垂直切分

按照不同的表切分到不同的数据库。

优点：

- 拆分后业务清晰，拆分规则明确。
- 系统之间整合或扩展容易。
- 数据维护简单。

缺点：

- 部分业务表无法 join，只能通过接口方式解决，提高了系统复杂度。
- 受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。
- 事务处理复杂。
- 由于垂直切分是按照业务的分类将表分散到不同的库，所以有些业务表会过于庞大，存在单库读写与存储瓶
- 颈，所以就需要水平拆分来做解决。

### 水平切分

根据表中的数据的逻辑关系，将同一表中的数据按照某种条件拆分到多台数据库中。

相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，**就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中**，如图：

拆分数据就需要定义分片规则。关系型数据库是行列的二维模型，拆分的第一原则是找到拆分维度。比如：

从会员的角度来分析，商户订单交易类系统中查询会员某天某月某个订单，那么就需要按照会员结合日期来拆分，不同的数据按照会员 ID 做分组，这样所有的数据查询 join 都会在单库内解决；如果从商户的角度来讲，要查询某个商家某天所有的订单数，就需要按照商户 ID 做拆分；但是如果系统既想按会员拆分，又想按商家数据，则会有一定的困难。如何找到合适的分片规则需要综合考虑衡量。

**几种典型的分片规则包括**：

- 按照用户 ID 求模，将数据分散到不同的数据库，具有相同数据用户的数据都被分散到一个库中；
- 按照日期，将不同月甚至日的数据分散到不同的库中；
- 按照某个特定的字段求摸，或者根据特定范围段分散到不同的库中

优点：

- 拆分规则抽象好，join 操作基本可以数据库做。
- 不存在单库大数据，高并发的性能瓶颈。
- 应用端改造较少。
- 提高了系统的稳定性跟负载能力。

缺点：

- 拆分规则难以抽象。
- 分片事务一致性难以解决。
- 数据多次扩展难度跟维护量极大。
- 跨库 join 性能较差。

## 密码

### 设置规则

这个其实与validate_password_policy的值有关，默认为1，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。
如果我们不希望密码设置的那么复杂，需要修改两个全局参数：`validate_password_length`默认值为8,最小值为4

`set global validate_password_policy=0;` 只验证长度
`set global validate_password_length=4；` 修改密码默认长度

### 用SET PASSWORD命令

配置root密码
`SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass');`

用户修改自己密码
`SET PASSWORD=PASSWORD('newpass');`

### 用mysqladmin

```shell
mysqladmin -u root password "newpass"
```

如果root已经设置过密码，采用如下方法
`mysqladmin -u root password oldpass "newpass"`

### 更改当前用户密码

```msyql
ALTER USER USER() IDENTIFIED BY '123456';
```

### 用UPDATE直接编辑user表

```mysql
use mysql;`
`UPDATE user SET Password = PASSWORD('newpass') WHERE user = 'root';`
`FLUSH PRIVILEGES;
```

### root密码丢失

关闭验证密码
`mysqld_safe --skip-grant-tables&`

登陆
`mysql -u root mysql`

重置
`UPDATE user SET password=PASSWORD("new password") WHERE user='root';`

5.7版本
`UPDATE user SET authentication_string=PASSWORD("new password") WHERE user='root';`

刷新
`FLUSH PRIVILEGES;

## 常用监控指标

TPS

```text
平均每秒sql语句执行次数
(com_commit+com_rollback)/uptime
```

QPS

```text
平均每秒事务数
questions/uptime
```

会话连接

```TEXT
当前全部会话
当前活跃会话
```

流量吞吐（KB）

```text
平均每秒从所有客户端接收到的字节数
平均每秒发送给所有客户端的字节数
```

刷盘次数

```text
innodb平均每秒fsync操作次数
```

打开文件数

innodb data读写吞吐量（KB）

```text
innodb平均每秒写数据量
innodb平均每秒读数据量
```

innodb buffer pool命中率

```text
innodb buffer pool脏页比率：
innodb_buffer_pool_pages_dirty/innodb_buffer_pool_pages_data*100%

innodb buffer pool读缓存命中率：
(innodb_buffer_pool_read_requests-innodb_buffer_pool_reads)/innodb_buffer_pool_read_requests*100%

innodb buffer pool使用率：
innodb_buffer_pool_pages_data/（innodb_buffer_pool_pages_data+innodb_buffer_pool_pages_free）*100%
```

innodb redo写次数

```text
innodb平均每秒物理写redo log file次数
平均每秒向日志文件完成的fsync()写数量
```

innodb row operations

```text
innodb平均每秒删除的行数
innodb平均每秒读取的行数
innodb平均每秒插入的行数
innodb平均每秒物理写redo log file次数
innodb平均每秒更新的行数
```

内存页

```text
innodb buffer pool刷page请求数量
innodb buffer pool中有脏页数量
```

行锁

```text
从系统启动到现在锁定总时间长度
innodb表平均等待row locks时间
innodb表平均等待row locks次数
```

cpu/内存利用率

存储空间使用量（MB）

```text
数据空间
临时空间
系统空间
日志空间
总空间
```

IOPS读写次数

## mysql怎么保持数据不丢的

只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。

## mysql怎么保持主备一致

虽然备库没有被直接访问，但还是建议备库设置为只读模式：

有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；

防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；

可以用 readonly 状态，来判断节点的角色。



正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。

## mySQL是怎么保证高可用的？

## 存储引擎

MyISAM：不支持事务处理，读性能处理快，表级别锁

InnoDB：**支持事务处理，行级别锁**

表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。
行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。
为什么会出现表锁和行锁呢？主要是为了保证数据的完整性，举个例子，一个用户在操作一张表，其他用户也想操作这张表，那么就要等第一个用户操作完，其他用户才能操作，表锁和行锁就是这个作用。否则多个用户同时操作一张表，肯定会数据产生冲突或者异常。
