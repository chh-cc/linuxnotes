**MySQL 是一种数据库。数据库定义了存储信息的结构。以表的方式存储信息，设置有索引可以快速定位到需要的内容，避免查找数据时要遍历整个库，耗费资源速度也太慢。**

## mysql对数据的管理

### 事务

多个操作被当做一个整体对待，要想看一个关系型管理数据库系统是否支持事务就要看关系型数据库系统是否满足ACID测试

- ACID 事务的一个基本标准

- - A:原子性
  - C:一致性
  - I:隔离性
  - D:持久性

举个例子：比如去银行存钱1000元，存钱是一个过程，服务器这个时候应该响应修改你的银行卡信息加1000元。这个时候就构成了一个**事务**。

但是如果刚存过钱服务器还没来的及响应，这个时候突然停电了（比如没有应急供电措施），这个时候钱是存过还是没存？这个时候需要利用事物的“回滚”功能，因为没有构成一个事物，恢复到还没有存钱之前的状态。

**要么全部都成功执行，要么全部都失败“回滚”**。

### SQL语句对数据库管理常用的两种方式：

- DDL：数据定义语言-主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用，**创建表的时候有问题看这里**。

- - CREATE： 创建
  - ALTER：改变
  - DROP： 删除
  
- DML：数据操纵语言-这4条命令是用来对数据库里的数据进行操作的语言，**修改表的时候有问题看这里**。

- - INSERT：添加
  - DELETE：删除
  - SELECT：选择
  - UPDATE：修改

## 体系结构

mysql主要分为server层和存储引擎层

server层主要包括连接器、查询缓冲、分析器、优化器、执行器等

存储引擎层主要负责数据的存储和读取



### 一条sql查询语句如何执行

**连接器**

第一步，你会先连接到这个数据库上。连接器负责跟客户端**建立连接、获取权限、维持和管理连接**

```shell
mysql -h$ip -P$port -u$user -p
```



连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它，command列会显示sleep。

**客户端如果太长时间没动静，连接器就会自动将它断开**。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。

数据库里面，**长连接**是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。**短连接**则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。



**查询缓冲**

`MySQL`中**数据是以页为单位**，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫**数据页，会放入到`Buffer Pool`中。**

**后续的查询都是先从`Buffer Pool`中找，没有命中再去硬盘加载，减少硬盘`IO`开销，提升性能。**

如果语句不在查询缓冲池中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓冲池中。

如果查询命中缓冲，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高



但是查询缓冲的失效非常频繁，**只要有对一个表的更新，这个表上所有的查询缓冲都会被清空**。

好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓冲。而对于你确定要使用查询缓冲的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

```shell
mysql> select SQL_CACHE * from T where ID=10；
```

需要注意的是，**MySQL 8.0 版本直接将查询缓冲的整块功能删掉了**，也就是说 8.0 开始彻底没有这个功能了。



**分析器**

没有命中缓存，就开始执行语句，执行语句之前MySQL 需要知道**你要做什么**

分析器先会做**“词法分析”**。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。

做完了这些识别以后，就要做**“语法分析”**。语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒



**优化器**

经过分析器mysql知道你要做什么后，**要决定怎么做**；优化器是在表里有多个索引的时候决定使用哪个索引，或者一个语句有多表关联（join）的时候决定各个表的连接顺序

优化器阶段完成后，这个语句的**执行方案就确定下来**了，然后进入执行器阶段



**执行器**

进入了执行器阶段，开始执行语句。

以这个语句为例：

```mysql
mysql> select * from T where ID=10;
```

执行器的执行流程是这样的：

调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；

调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。

执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。





执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再**调用引擎接口写入**这行新数据。

引擎将这行新数据更新到内存中，同时**将这个更新操作记录到 redo log** 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

执行器**生成这个操作的 binlog**，并把 binlog 写入磁盘。

执行器**调用引擎的提交事务接口**，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。